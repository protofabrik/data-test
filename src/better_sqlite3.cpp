"// better_sqlite3.cpp\n//\n\n#include \"better_sqlite3.hpp\"\n#line 67 \"./src/better_sqlite3.lzz\"\nNODE_MODULE_INIT(/* exports, context */) {\n\tv8::Isolate* isolate = context->GetIsolate();\n\tv8::HandleScope scope(isolate);\n\n\t// Initialize addon instance.\n\tAddon* addon = new Addon(isolate);\n\tv8::Local<v8::External> data = v8::External::New(isolate, addon);\n\tnode::AddEnvironmentCleanupHook(isolate, Addon::Cleanup, addon);\n\n\t// Create and export native-backed classes and functions.\n\texports->Set(context, InternalizedFromLatin1(isolate, \"Database\"), Database::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"Statement\"), Statement::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"StatementIterator\"), StatementIterator::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"Backup\"), Backup::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"setErrorConstructor\"), v8::FunctionTemplate::New(isolate, Addon::JS_setErrorConstructor, data)->GetFunction(context).ToLocalChecked()).FromJust();\n\n\t// Store addon instance data.\n\taddon->Statement.Reset(isolate, v8::Local<v8::Function>::Cast(exports->Get(context, InternalizedFromLatin1(isolate, \"Statement\")).ToLocalChecked()));\n\taddon->StatementIterator.Reset(isolate, v8::Local<v8::Function>::Cast(exports->Get(context, InternalizedFromLatin1(isolate, \"StatementIterator\")).ToLocalChecked()));\n\taddon->Backup.Reset(isolate, v8::Local<v8::Function>::Cast(exports->Get(context, InternalizedFromLatin1(isolate, \"Backup\")).ToLocalChecked()));\n}\n#define LZZ_INLINE inline\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 69 \"./src/util/data.lzz\"\n  static char const FLAT = 0;\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 70 \"./src/util/data.lzz\"\n  static char const PLUCK = 1;\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 71 \"./src/util/data.lzz\"\n  static char const EXPAND = 2;\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 72 \"./src/util/data.lzz\"\n  static char const RAW = 3;\n}\n#line 37 \"./src/util/macros.lzz\"\nvoid ThrowError (char const * message)\n#line 37 \"./src/util/macros.lzz\"\n                                     { v8 :: Isolate * isolate = v8 :: Isolate :: GetCurrent ( ) ; isolate->ThrowException(v8::Exception::Error(StringFromUtf8(isolate, message, -1)));\n}\n#line 38 \"./src/util/macros.lzz\"\nvoid ThrowTypeError (char const * message)\n#line 38 \"./src/util/macros.lzz\"\n                                         { v8 :: Isolate * isolate = v8 :: Isolate :: GetCurrent ( ) ; isolate->ThrowException(v8::Exception::TypeError(StringFromUtf8(isolate, message, -1)));\n}\n#line 39 \"./src/util/macros.lzz\"\nvoid ThrowRangeError (char const * message)\n#line 39 \"./src/util/macros.lzz\"\n                                          { v8 :: Isolate * isolate = v8 :: Isolate :: GetCurrent ( ) ; isolate->ThrowException(v8::Exception::RangeError(StringFromUtf8(isolate, message, -1)));\n}\n#line 91 \"./src/util/macros.lzz\"\nstd::string CONCAT (char const * a, char const * b, char const * c)\n#line 91 \"./src/util/macros.lzz\"\n                                                                {\n        std::string result(a);\n        result += b;\n        result += c;\n        return result;\n}\n#line 99 \"./src/util/macros.lzz\"\nchar const * COPY (char const * source)\n#line 99 \"./src/util/macros.lzz\"\n                                     {\n        size_t bytes = strlen(source) + 1;\n        char* dest = new char[bytes];\n        memcpy(dest, source, bytes);\n        return dest;\n}\n#line 121 \"./src/util/macros.lzz\"\nv8::Local <v8::FunctionTemplate> NewConstructorTemplate (v8::Isolate * isolate, v8::Local <v8::External> data, v8::FunctionCallback func, char const * name)\n#line 126 \"./src/util/macros.lzz\"\n  {\n        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, func, data);\n        t->InstanceTemplate()->SetInternalFieldCount(1);\n        t->SetClassName(InternalizedFromLatin1(isolate, name));\n        return t;\n}\n#line 132 \"./src/util/macros.lzz\"\nvoid SetPrototypeMethod (v8::Isolate * isolate, v8::Local <v8::External> data, v8::Local <v8::FunctionTemplate> recv, char const * name, v8::FunctionCallback func)\n#line 138 \"./src/util/macros.lzz\"\n  {\n        v8::HandleScope scope(isolate);\n        recv->PrototypeTemplate()->Set(\n                InternalizedFromLatin1(isolate, name),\n                v8::FunctionTemplate::New(isolate, func, data, v8::Signature::New(isolate, recv))\n        );\n}\n#line 145 \"./src/util/macros.lzz\"\nvoid SetPrototypeSymbolMethod (v8::Isolate * isolate, v8::Local <v8::External> data, v8::Local <v8::FunctionTemplate> recv, v8::Local <v8::Symbol> symbol, v8::FunctionCallback func)\n#line 151 \"./src/util/macros.lzz\"\n  {\n        v8::HandleScope scope(isolate);\n        recv->PrototypeTemplate()->Set(\n                symbol,\n                v8::FunctionTemplate::New(isolate, func, data, v8::Signature::New(isolate, recv))\n        );\n}\n#line 158 \"./src/util/macros.lzz\"\nvoid SetPrototypeGetter (v8::Isolate * isolate, v8::Local <v8::External> data, v8::Local <v8::FunctionTemplate> recv, char const * name, v8::AccessorGetterCallback func)\n#line 164 \"./src/util/macros.lzz\"\n  {\n        v8::HandleScope scope(isolate);\n        recv->InstanceTemplate()->SetAccessor(\n                InternalizedFromLatin1(isolate, name),\n                func,\n                0,\n                data,\n                v8::AccessControl::DEFAULT,\n                v8::PropertyAttribute::None,\n                v8::AccessorSignature::New(isolate, recv)\n        );\n}\n#line 7 \"./src/util/constants.lzz\"\nv8::Local <v8::String> CS::Code (v8::Isolate * isolate, int code)\n#line 7 \"./src/util/constants.lzz\"\n                                                                   {\n                auto element = codes.find(code);\n                if (element != codes.end()) return v8::Local<v8::String>::New(isolate, element->second);\n                return StringFromUtf8(isolate, CONCAT(\"UNKNOWN_SQLITE_ERROR_\", std::to_string(code).c_str(), \"\").c_str(), -1);\n}\n#line 13 \"./src/util/constants.lzz\"\nCS::CS (v8::Isolate * isolate)\n#line 13 \"./src/util/constants.lzz\"\n                                          {\n                SetString(isolate, database, \"database\");\n                SetString(isolate, reader, \"reader\");\n                SetString(isolate, source, \"source\");\n                SetString(isolate, memory, \"memory\");\n                SetString(isolate, readonly, \"readonly\");\n                SetString(isolate, name, \"name\");\n                SetString(isolate, next, \"next\");\n                SetString(isolate, length, \"length\");\n                SetString(isolate, done, \"done\");\n                SetString(isolate, value, \"value\");\n                SetString(isolate, changes, \"changes\");\n                SetString(isolate, lastInsertRowid, \"lastInsertRowid\");\n                SetString(isolate, statement, \"statement\");\n                SetString(isolate, column, \"column\");\n                SetString(isolate, table, \"table\");\n                SetString(isolate, type, \"type\");\n                SetString(isolate, totalPages, \"totalPages\");\n                SetString(isolate, remainingPages, \"remainingPages\");\n\n                SetCode(isolate, SQLITE_OK, \"SQLITE_OK\");\n                SetCode(isolate, SQLITE_ERROR, \"SQLITE_ERROR\");\n                SetCode(isolate, SQLITE_INTERNAL, \"SQLITE_INTERNAL\");\n                SetCode(isolate, SQLITE_PERM, \"SQLITE_PERM\");\n                SetCode(isolate, SQLITE_ABORT, \"SQLITE_ABORT\");\n                SetCode(isolate, SQLITE_BUSY, \"SQLITE_BUSY\");\n                SetCode(isolate, SQLITE_LOCKED, \"SQLITE_LOCKED\");\n                SetCode(isolate, SQLITE_NOMEM, \"SQLITE_NOMEM\");\n                SetCode(isolate, SQLITE_READONLY, \"SQLITE_READONLY\");\n                SetCode(isolate, SQLITE_INTERRUPT, \"SQLITE_INTERRUPT\");\n                SetCode(isolate, SQLITE_IOERR, \"SQLITE_IOERR\");\n                SetCode(isolate, SQLITE_CORRUPT, \"SQLITE_CORRUPT\");\n                SetCode(isolate, SQLITE_NOTFOUND, \"SQLITE_NOTFOUND\");\n                SetCode(isolate, SQLITE_FULL, \"SQLITE_FULL\");\n                SetCode(isolate, SQLITE_CANTOPEN, \"SQLITE_CANTOPEN\");\n                SetCode(isolate, SQLITE_PROTOCOL, \"SQLITE_PROTOCOL\");\n                SetCode(isolate, SQLITE_EMPTY, \"SQLITE_EMPTY\");\n                SetCode(isolate, SQLITE_SCHEMA, \"SQLITE_SCHEMA\");\n                SetCode(isolate, SQLITE_TOOBIG, \"SQLITE_TOOBIG\");\n                SetCode(isolate, SQLITE_CONSTRAINT, \"SQLITE_CONSTRAINT\");\n                SetCode(isolate, SQLITE_MISMATCH, \"SQLITE_MISMATCH\");\n                SetCode(isolate, SQLITE_MISUSE, \"SQLITE_MISUSE\");\n                SetCode(isolate, SQLITE_NOLFS, \"SQLITE_NOLFS\");\n                SetCode(isolate, SQLITE_AUTH, \"SQLITE_AUTH\");\n                SetCode(isolate, SQLITE_FORMAT, \"SQLITE_FORMAT\");\n                SetCode(isolate, SQLITE_RANGE, \"SQLITE_RANGE\");\n                SetCode(isolate, SQLITE_NOTADB, \"SQLITE_NOTADB\");\n                SetCode(isolate, SQLITE_NOTICE, \"SQLITE_NOTICE\");\n                SetCode(isolate, SQLITE_WARNING, \"SQLITE_WARNING\");\n                SetCode(isolate, SQLITE_ROW, \"SQLITE_ROW\");\n                SetCode(isolate, SQLITE_DONE, \"SQLITE_DONE\");\n                SetCode(isolate, SQLITE_IOERR_READ, \"SQLITE_IOERR_READ\");\n                SetCode(isolate, SQLITE_IOERR_SHORT_READ, \"SQLITE_IOERR_SHORT_READ\");\n                SetCode(isolate, SQLITE_IOERR_WRITE, \"SQLITE_IOERR_WRITE\");\n                SetCode(isolate, SQLITE_IOERR_FSYNC, \"SQLITE_IOERR_FSYNC\");\n                SetCode(isolate, SQLITE_IOERR_DIR_FSYNC, \"SQLITE_IOERR_DIR_FSYNC\");\n                SetCode(isolate, SQLITE_IOERR_TRUNCATE, \"SQLITE_IOERR_TRUNCATE\");\n                SetCode(isolate, SQLITE_IOERR_FSTAT, \"SQLITE_IOERR_FSTAT\");\n                SetCode(isolate, SQLITE_IOERR_UNLOCK, \"SQLITE_IOERR_UNLOCK\");\n                SetCode(isolate, SQLITE_IOERR_RDLOCK, \"SQLITE_IOERR_RDLOCK\");\n                SetCode(isolate, SQLITE_IOERR_DELETE, \"SQLITE_IOERR_DELETE\");\n                SetCode(isolate, SQLITE_IOERR_BLOCKED, \"SQLITE_IOERR_BLOCKED\");\n                SetCode(isolate, SQLITE_IOERR_NOMEM, \"SQLITE_IOERR_NOMEM\");\n                SetCode(isolate, SQLITE_IOERR_ACCESS, \"SQLITE_IOERR_ACCESS\");\n                SetCode(isolate, SQLITE_IOERR_CHECKRESERVEDLOCK, \"SQLITE_IOERR_CHECKRESERVEDLOCK\");\n                SetCode(isolate, SQLITE_IOERR_LOCK, \"SQLITE_IOERR_LOCK\");\n                SetCode(isolate, SQLITE_IOERR_CLOSE, \"SQLITE_IOERR_CLOSE\");\n                SetCode(isolate, SQLITE_IOERR_DIR_CLOSE, \"SQLITE_IOERR_DIR_CLOSE\");\n                SetCode(isolate, SQLITE_IOERR_SHMOPEN, \"SQLITE_IOERR_SHMOPEN\");\n                SetCode(isolate, SQLITE_IOERR_SHMSIZE, \"SQLITE_IOERR_SHMSIZE\");\n                SetCode(isolate, SQLITE_IOERR_SHMLOCK, \"SQLITE_IOERR_SHMLOCK\");\n                SetCode(isolate, SQLITE_IOERR_SHMMAP, \"SQLITE_IOERR_SHMMAP\");\n                SetCode(isolate, SQLITE_IOERR_SEEK, \"SQLITE_IOERR_SEEK\");\n                SetCode(isolate, SQLITE_IOERR_DELETE_NOENT, \"SQLITE_IOERR_DELETE_NOENT\");\n                SetCode(isolate, SQLITE_IOERR_MMAP, \"SQLITE_IOERR_MMAP\");\n                SetCode(isolate, SQLITE_IOERR_GETTEMPPATH, \"SQLITE_IOERR_GETTEMPPATH\");\n                SetCode(isolate, SQLITE_IOERR_CONVPATH, \"SQLITE_IOERR_CONVPATH\");\n                SetCode(isolate, SQLITE_IOERR_VNODE, \"SQLITE_IOERR_VNODE\");\n                SetCode(isolate, SQLITE_IOERR_AUTH, \"SQLITE_IOERR_AUTH\");\n                SetCode(isolate, SQLITE_LOCKED_SHAREDCACHE, \"SQLITE_LOCKED_SHAREDCACHE\");\n                SetCode(isolate, SQLITE_BUSY_RECOVERY, \"SQLITE_BUSY_RECOVERY\");\n                SetCode(isolate, SQLITE_BUSY_SNAPSHOT, \"SQLITE_BUSY_SNAPSHOT\");\n                SetCode(isolate, SQLITE_CANTOPEN_NOTEMPDIR, \"SQLITE_CANTOPEN_NOTEMPDIR\");\n                SetCode(isolate, SQLITE_CANTOPEN_ISDIR, \"SQLITE_CANTOPEN_ISDIR\");\n                SetCode(isolate, SQLITE_CANTOPEN_FULLPATH, \"SQLITE_CANTOPEN_FULLPATH\");\n                SetCode(isolate, SQLITE_CANTOPEN_CONVPATH, \"SQLITE_CANTOPEN_CONVPATH\");\n                SetCode(isolate, SQLITE_CORRUPT_VTAB, \"SQLITE_CORRUPT_VTAB\");\n                SetCode(isolate, SQLITE_READONLY_RECOVERY, \"SQLITE_READONLY_RECOVERY\");\n                SetCode(isolate, SQLITE_READONLY_CANTLOCK, \"SQLITE_READONLY_CANTLOCK\");\n                SetCode(isolate, SQLITE_READONLY_ROLLBACK, \"SQLITE_READONLY_ROLLBACK\");\n                SetCode(isolate, SQLITE_READONLY_DBMOVED, \"SQLITE_READONLY_DBMOVED\");\n                SetCode(isolate, SQLITE_ABORT_ROLLBACK, \"SQLITE_ABORT_ROLLBACK\");\n                SetCode(isolate, SQLITE_CONSTRAINT_CHECK, \"SQLITE_CONSTRAINT_CHECK\");\n                SetCode(isolate, SQLITE_CONSTRAINT_COMMITHOOK, \"SQLITE_CONSTRAINT_COMMITHOOK\");\n                SetCode(isolate, SQLITE_CONSTRAINT_FOREIGNKEY, \"SQLITE_CONSTRAINT_FOREIGNKEY\");\n                SetCode(isolate, SQLITE_CONSTRAINT_FUNCTION, \"SQLITE_CONSTRAINT_FUNCTION\");\n                SetCode(isolate, SQLITE_CONSTRAINT_NOTNULL, \"SQLITE_CONSTRAINT_NOTNULL\");\n                SetCode(isolate, SQLITE_CONSTRAINT_PRIMARYKEY, \"SQLITE_CONSTRAINT_PRIMARYKEY\");\n                SetCode(isolate, SQLITE_CONSTRAINT_TRIGGER, \"SQLITE_CONSTRAINT_TRIGGER\");\n                SetCode(isolate, SQLITE_CONSTRAINT_UNIQUE, \"SQLITE_CONSTRAINT_UNIQUE\");\n                SetCode(isolate, SQLITE_CONSTRAINT_VTAB, \"SQLITE_CONSTRAINT_VTAB\");\n                SetCode(isolate, SQLITE_CONSTRAINT_ROWID, \"SQLITE_CONSTRAINT_ROWID\");\n                SetCode(isolate, SQLITE_NOTICE_RECOVER_WAL, \"SQLITE_NOTICE_RECOVER_WAL\");\n                SetCode(isolate, SQLITE_NOTICE_RECOVER_ROLLBACK, \"SQLITE_NOTICE_RECOVER_ROLLBACK\");\n                SetCode(isolate, SQLITE_WARNING_AUTOINDEX, \"SQLITE_WARNING_AUTOINDEX\");\n                SetCode(isolate, SQLITE_AUTH_USER, \"SQLITE_AUTH_USER\");\n                SetCode(isolate, SQLITE_OK_LOAD_PERMANENTLY, \"SQLITE_OK_LOAD_PERMANENTLY\");\n}\n#line 142 \"./src/util/constants.lzz\"\nvoid CS::SetString (v8::Isolate * isolate, CopyablePersistent <v8::String> & constant, char const * str)\n#line 142 \"./src/util/constants.lzz\"\n                                                                                                               {\n                constant.Reset(isolate, InternalizedFromLatin1(isolate, str));\n}\n#line 145 \"./src/util/constants.lzz\"\nvoid CS::SetCode (v8::Isolate * isolate, int code, char const * str)\n#line 145 \"./src/util/constants.lzz\"\n                                                                      {\n                codes.emplace(std::piecewise_construct, std::forward_as_tuple(code), std::forward_as_tuple(isolate, InternalizedFromLatin1(isolate, str)));\n}\n#line 19 \"./src/util/bind-map.lzz\"\nBindMap::Pair::Pair (v8::Isolate * isolate, char const * _name, int _index)\n#line 20 \"./src/util/bind-map.lzz\"\n  : name (isolate, InternalizedFromUtf8(isolate, _name, -1)), index (_index)\n#line 20 \"./src/util/bind-map.lzz\"\n                                                                                                         {}\n#line 22 \"./src/util/bind-map.lzz\"\nBindMap::Pair::Pair (v8::Isolate * isolate, Pair * pair)\n#line 23 \"./src/util/bind-map.lzz\"\n  : name (isolate, pair->name), index (pair->index)\n#line 23 \"./src/util/bind-map.lzz\"\n                                                                                {}\n#line 29 \"./src/util/bind-map.lzz\"\nBindMap::BindMap (char _)\n#line 29 \"./src/util/bind-map.lzz\"\n                                 {\n                assert(_ == 0);\n                pairs = NULL;\n                capacity = 0;\n                length = 0;\n}\n#line 36 \"./src/util/bind-map.lzz\"\nBindMap::~ BindMap ()\n#line 36 \"./src/util/bind-map.lzz\"\n                   {\n                while (length) pairs[--length].~Pair();\n                FREE_ARRAY<Pair>(pairs);\n}\n#line 45 \"./src/util/bind-map.lzz\"\nvoid BindMap::Add (v8::Isolate * isolate, char const * name, int index)\n#line 45 \"./src/util/bind-map.lzz\"\n                                                                    {\n                assert(name != NULL);\n                if (capacity == length) Grow(isolate);\n                new (pairs + length++) Pair(isolate, name, index);\n}\n#line 52 \"./src/util/bind-map.lzz\"\nvoid BindMap::Grow (v8::Isolate * isolate)\n#line 52 \"./src/util/bind-map.lzz\"\n                                        {\n                assert(capacity == length);\n                capacity = (capacity << 1) | 2;\n                Pair* new_pairs = ALLOC_ARRAY<Pair>(capacity);\n                for (int i=0; i<length; ++i) {\n                        new (new_pairs + i) Pair(isolate, pairs + i);\n                        pairs[i].~Pair();\n                }\n                FREE_ARRAY<Pair>(pairs);\n                pairs = new_pairs;\n}\n#line 4 \"./src/objects/database.lzz\"\nv8::Local <v8 :: Function> Database::Init (v8::Isolate * isolate, v8::Local <v8 :: External> data)\n#line 4 \"./src/objects/database.lzz\"\n                   {\n                v8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"Database\");\n                SetPrototypeMethod(isolate, data, t, \"prepare\", JS_prepare);\n                SetPrototypeMethod(isolate, data, t, \"exec\", JS_exec);\n                SetPrototypeMethod(isolate, data, t, \"pragma\", JS_pragma);\n                SetPrototypeMethod(isolate, data, t, \"backup\", JS_backup);\n                SetPrototypeMethod(isolate, data, t, \"function\", JS_function);\n                SetPrototypeMethod(isolate, data, t, \"aggregate\", JS_aggregate);\n                SetPrototypeMethod(isolate, data, t, \"loadExtension\", JS_loadExtension);\n                SetPrototypeMethod(isolate, data, t, \"close\", JS_close);\n                SetPrototypeMethod(isolate, data, t, \"defaultSafeIntegers\", JS_defaultSafeIntegers);\n                SetPrototypeMethod(isolate, data, t, \"unsafeMode\", JS_unsafeMode);\n                SetPrototypeGetter(isolate, data, t, \"open\", JS_open);\n                SetPrototypeGetter(isolate, data, t, \"inTransaction\", JS_inTransaction);\n                return t->GetFunction( isolate -> GetCurrentContext ( ) ).ToLocalChecked();\n}\n#line 23 \"./src/objects/database.lzz\"\nbool Database::CompareDatabase::operator () (Database const * const a, Database const * const b) const\n#line 23 \"./src/objects/database.lzz\"\n                                                                                           {\n                        return a < b;\n}\n#line 28 \"./src/objects/database.lzz\"\nbool Database::CompareStatement::operator () (Statement const * const a, Statement const * const b) const\n#line 28 \"./src/objects/database.lzz\"\n                                                                                             {\n                        return Statement::Compare(a, b);\n}\n#line 33 \"./src/objects/database.lzz\"\nbool Database::CompareBackup::operator () (Backup const * const a, Backup const * const b) const\n#line 33 \"./src/objects/database.lzz\"\n                                                                                       {\n                        return Backup::Compare(a, b);\n}\n#line 39 \"./src/objects/database.lzz\"\nvoid Database::ThrowDatabaseError ()\n#line 39 \"./src/objects/database.lzz\"\n                                  {\n                if (was_js_error) was_js_error = false;\n                else ThrowSqliteError(addon, db_handle);\n}\n#line 43 \"./src/objects/database.lzz\"\nvoid Database::ThrowSqliteError (Addon * addon, sqlite3 * db_handle)\n#line 43 \"./src/objects/database.lzz\"\n                                                                       {\n                assert(db_handle != NULL);\n                ThrowSqliteError(addon, sqlite3_errmsg(db_handle), sqlite3_extended_errcode(db_handle));\n}\n#line 47 \"./src/objects/database.lzz\"\nvoid Database::ThrowSqliteError (Addon * addon, char const * message, int code)\n#line 47 \"./src/objects/database.lzz\"\n                                                                                  {\n                assert(message != NULL);\n                assert((code & 0xff) != SQLITE_OK);\n                assert((code & 0xff) != SQLITE_ROW);\n                assert((code & 0xff) != SQLITE_DONE);\n                v8 :: Isolate * isolate = v8 :: Isolate :: GetCurrent ( ) ;\n                v8::Local<v8::Value> args[2] = {\n                        StringFromUtf8(isolate, message, -1),\n                        addon->cs.Code(isolate, code)\n                };\n                isolate->ThrowException(v8::Local<v8::Function>::New(isolate, addon->SqliteError)\n                        ->NewInstance( isolate -> GetCurrentContext ( ) , 2, args)\n                        .ToLocalChecked());\n}\n#line 63 \"./src/objects/database.lzz\"\nbool Database::Log (v8::Isolate * isolate, sqlite3_stmt * handle)\n#line 63 \"./src/objects/database.lzz\"\n                                                             {\n                assert(was_js_error == false);\n                if (!has_logger) return false;\n                char* expanded = sqlite3_expanded_sql(handle);\n                v8::Local<v8::Value> arg = StringFromUtf8(isolate, expanded ? expanded : sqlite3_sql(handle), -1);\n                was_js_error = v8::Local<v8::Function>::Cast(v8::Local<v8::Value>::New(isolate, logger))\n                        ->Call( isolate -> GetCurrentContext ( ) , v8::Undefined(isolate), 1, &arg)\n                        .IsEmpty();\n                if (expanded) sqlite3_free(expanded);\n                return was_js_error;\n}\n#line 106 \"./src/objects/database.lzz\"\nvoid Database::CloseHandles ()\n#line 106 \"./src/objects/database.lzz\"\n                            {\n                if (open) {\n                        open = false;\n                        for (Statement* stmt : stmts) stmt->CloseHandles();\n                        for (Backup* backup : backups) backup->CloseHandles();\n                        stmts.clear();\n                        backups.clear();\n                        int status = sqlite3_close(db_handle);\n                        assert(status == SQLITE_OK); ((void)status);\n                }\n}\n#line 118 \"./src/objects/database.lzz\"\nDatabase::~ Database ()\n#line 118 \"./src/objects/database.lzz\"\n                    {\n                if (open) addon->dbs.erase(this);\n                CloseHandles();\n}\n#line 125 \"./src/objects/database.lzz\"\nDatabase::Database (sqlite3 * _db_handle, v8::Isolate * isolate, Addon * _addon, v8::Local <v8::Value> _logger)\n#line 125 \"./src/objects/database.lzz\"\n  : node::ObjectWrap (), db_handle (_db_handle), open (true), busy (false), safe_ints (false), unsafe_mode (false), was_js_error (false), has_logger (_logger->IsFunction()), iterators (0), addon (_addon), logger (isolate, _logger), stmts (), backups ()\n#line 137 \"./src/objects/database.lzz\"\n                          {\n                assert(_db_handle != NULL);\n                addon->dbs.insert(this);\n}\n#line 142 \"./src/objects/database.lzz\"\nvoid Database::JS_new (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 142 \"./src/objects/database.lzz\"\n                            {\n                assert(info.IsConstructCall());\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > filename = v8 :: Local < v8 :: String > :: Cast ( info [ 0 ] ) ;\n                if ( info . Length ( ) <= ( 1 ) || ! info [ 1 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"second\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > filenameGiven = v8 :: Local < v8 :: String > :: Cast ( info [ 1 ] ) ;\n                if ( info . Length ( ) <= ( 2 ) || ! info [ 2 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"third\" \" argument to be \" \"a boolean\" ) ; bool in_memory = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 2 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 3 ) || ! info [ 3 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"fourth\" \" argument to be \" \"a boolean\" ) ; bool readonly = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 3 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 4 ) || ! info [ 4 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"fifth\" \" argument to be \" \"a boolean\" ) ; bool must_exist = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 4 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 5 ) || ! info [ 5 ] -> IsInt32 ( ) ) return ThrowTypeError ( \"Expected \" \"sixth\" \" argument to be \" \"a 32-bit signed integer\" ) ; int timeout = v8 :: Local < v8 :: Int32 > :: Cast ( info [ 5 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 6 ) ) return ThrowTypeError ( \"Expected a \" \"seventh\" \" argument\" ) ; v8 :: Local < v8 :: Value > logger = info [ 6 ] ;\n\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                sqlite3* db_handle;\n                v8::String::Utf8Value utf8(isolate, filename);\n                int mask = readonly ? SQLITE_OPEN_READONLY\n                        : must_exist ? SQLITE_OPEN_READWRITE\n                        : (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);\n\n                if (sqlite3_open_v2(*utf8, &db_handle, mask, NULL) != SQLITE_OK) {\n                        ThrowSqliteError(addon, db_handle);\n                        int status = sqlite3_close(db_handle);\n                        assert(status == SQLITE_OK); ((void)status);\n                        return;\n                }\n\n                assert(sqlite3_db_mutex(db_handle) == NULL);\n                sqlite3_extended_result_codes(db_handle, 1);\n                sqlite3_busy_timeout(db_handle, timeout);\n                sqlite3_limit(db_handle, SQLITE_LIMIT_LENGTH, MAX_BUFFER_SIZE < MAX_STRING_SIZE ? MAX_BUFFER_SIZE : MAX_STRING_SIZE);\n                sqlite3_limit(db_handle, SQLITE_LIMIT_SQL_LENGTH, MAX_STRING_SIZE);\n                int status = sqlite3_db_config(db_handle, SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, 1, NULL);\n                assert(status == SQLITE_OK);\n                status = sqlite3_db_config(db_handle, SQLITE_DBCONFIG_DEFENSIVE, 1, NULL);\n                assert(status == SQLITE_OK);\n\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                Database* db = new Database(db_handle, isolate, addon, logger);\n                db->Wrap(info.This());\n                SetFrozen(isolate, ctx, info.This(), addon->cs.memory, v8::Boolean::New(isolate, in_memory));\n                SetFrozen(isolate, ctx, info.This(), addon->cs.readonly, v8::Boolean::New(isolate, readonly));\n                SetFrozen(isolate, ctx, info.This(), addon->cs.name, filenameGiven);\n\n                info.GetReturnValue().Set(info.This());\n}\n#line 187 \"./src/objects/database.lzz\"\nvoid Database::JS_prepare (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 187 \"./src/objects/database.lzz\"\n                                {\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > source = v8 :: Local < v8 :: String > :: Cast ( info [ 0 ] ) ;\n                (void)source;\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, addon->Statement);\n                addon->privileged_info = &info;\n                v8::MaybeLocal<v8::Object> maybe_statement = c->NewInstance( isolate -> GetCurrentContext ( ) , 0, NULL);\n                addon->privileged_info = NULL;\n                if (!maybe_statement.IsEmpty()) info.GetReturnValue().Set(maybe_statement.ToLocalChecked());\n}\n#line 199 \"./src/objects/database.lzz\"\nvoid Database::JS_exec (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 199 \"./src/objects/database.lzz\"\n                             {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > source = v8 :: Local < v8 :: String > :: Cast ( info [ 0 ] ) ;\n                if ( ! db -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( db -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( ! db -> unsafe_mode ) { if ( db -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; } ( ( void ) 0 ) ;\n                db->busy = true;\n\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::String::Utf8Value utf8(isolate, source);\n                const char* sql = *utf8;\n                const char* tail;\n\n                int status;\n                const bool has_logger = db->has_logger;\n                sqlite3* const db_handle = db->db_handle;\n                sqlite3_stmt* handle;\n\n                for (;;) {\n                        while (IS_SKIPPED(*sql)) ++sql;\n                        status = sqlite3_prepare_v2(db_handle, sql, -1, &handle, &tail);\n                        sql = tail;\n                        if (!handle) break;\n                        if (has_logger && db->Log(isolate, handle)) {\n                                sqlite3_finalize(handle);\n                                status = -1;\n                                break;\n                        }\n                        do status = sqlite3_step(handle);\n                        while (status == SQLITE_ROW);\n                        status = sqlite3_finalize(handle);\n                        if (status != SQLITE_OK) break;\n                }\n\n                db->busy = false;\n                if (status == SQLITE_OK) info.GetReturnValue().Set(info.This());\n                else db->ThrowDatabaseError();\n}\n#line 238 \"./src/objects/database.lzz\"\nvoid Database::JS_pragma (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 238 \"./src/objects/database.lzz\"\n                               {\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; bool active = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ;\n                static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ->SetPragmaMode(active);\n}\n#line 243 \"./src/objects/database.lzz\"\nvoid Database::JS_backup (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 243 \"./src/objects/database.lzz\"\n                               {\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > attachedName = v8 :: Local < v8 :: String > :: Cast ( info [ 0 ] ) ;\n                if ( info . Length ( ) <= ( 1 ) || ! info [ 1 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"second\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > destFile = v8 :: Local < v8 :: String > :: Cast ( info [ 1 ] ) ;\n                if ( info . Length ( ) <= ( 2 ) || ! info [ 2 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"third\" \" argument to be \" \"a boolean\" ) ; bool unlink = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 2 ] ) -> Value ( ) ;\n                (void)attachedName;\n                (void)destFile;\n                (void)unlink;\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, addon->Backup);\n                addon->privileged_info = &info;\n                v8::MaybeLocal<v8::Object> maybe_backup = c->NewInstance( isolate -> GetCurrentContext ( ) , 0, NULL);\n                addon->privileged_info = NULL;\n                if (!maybe_backup.IsEmpty()) info.GetReturnValue().Set(maybe_backup.ToLocalChecked());\n}\n#line 259 \"./src/objects/database.lzz\"\nvoid Database::JS_function (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 259 \"./src/objects/database.lzz\"\n                                 {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsFunction ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a function\" ) ; v8 :: Local < v8 :: Function > fn = v8 :: Local < v8 :: Function > :: Cast ( info [ 0 ] ) ;\n                if ( info . Length ( ) <= ( 1 ) || ! info [ 1 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"second\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > nameString = v8 :: Local < v8 :: String > :: Cast ( info [ 1 ] ) ;\n                if ( info . Length ( ) <= ( 2 ) || ! info [ 2 ] -> IsInt32 ( ) ) return ThrowTypeError ( \"Expected \" \"third\" \" argument to be \" \"a 32-bit signed integer\" ) ; int argc = v8 :: Local < v8 :: Int32 > :: Cast ( info [ 2 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 3 ) || ! info [ 3 ] -> IsInt32 ( ) ) return ThrowTypeError ( \"Expected \" \"fourth\" \" argument to be \" \"a 32-bit signed integer\" ) ; int safe_ints = v8 :: Local < v8 :: Int32 > :: Cast ( info [ 3 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 4 ) || ! info [ 4 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"fifth\" \" argument to be \" \"a boolean\" ) ; bool deterministic = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 4 ] ) -> Value ( ) ;\n                if ( ! db -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( db -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( db -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::String::Utf8Value name(isolate, nameString);\n                int mask = deterministic ? SQLITE_UTF8 | SQLITE_DETERMINISTIC : SQLITE_UTF8;\n                safe_ints = safe_ints < 2 ? safe_ints : static_cast<int>(db->safe_ints);\n\n                if (sqlite3_create_function_v2(db->db_handle, *name, argc, mask, new CustomFunction(isolate, db, fn, *name, safe_ints), CustomFunction::xFunc, NULL, NULL, CustomFunction::xDestroy) != SQLITE_OK) {\n                        return db->ThrowDatabaseError();\n                }\n                info.GetReturnValue().Set(info.This());\n}\n#line 281 \"./src/objects/database.lzz\"\nvoid Database::JS_aggregate (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 281 \"./src/objects/database.lzz\"\n                                  {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                if ( info . Length ( ) <= ( 0 ) ) return ThrowTypeError ( \"Expected a \" \"first\" \" argument\" ) ; v8 :: Local < v8 :: Value > start = info [ 0 ] ;\n                if ( info . Length ( ) <= ( 1 ) || ! info [ 1 ] -> IsFunction ( ) ) return ThrowTypeError ( \"Expected \" \"second\" \" argument to be \" \"a function\" ) ; v8 :: Local < v8 :: Function > step = v8 :: Local < v8 :: Function > :: Cast ( info [ 1 ] ) ;\n                if ( info . Length ( ) <= ( 2 ) ) return ThrowTypeError ( \"Expected a \" \"third\" \" argument\" ) ; v8 :: Local < v8 :: Value > inverse = info [ 2 ] ;\n                if ( info . Length ( ) <= ( 3 ) ) return ThrowTypeError ( \"Expected a \" \"fourth\" \" argument\" ) ; v8 :: Local < v8 :: Value > result = info [ 3 ] ;\n                if ( info . Length ( ) <= ( 4 ) || ! info [ 4 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"fifth\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > nameString = v8 :: Local < v8 :: String > :: Cast ( info [ 4 ] ) ;\n                if ( info . Length ( ) <= ( 5 ) || ! info [ 5 ] -> IsInt32 ( ) ) return ThrowTypeError ( \"Expected \" \"sixth\" \" argument to be \" \"a 32-bit signed integer\" ) ; int argc = v8 :: Local < v8 :: Int32 > :: Cast ( info [ 5 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 6 ) || ! info [ 6 ] -> IsInt32 ( ) ) return ThrowTypeError ( \"Expected \" \"seventh\" \" argument to be \" \"a 32-bit signed integer\" ) ; int safe_ints = v8 :: Local < v8 :: Int32 > :: Cast ( info [ 6 ] ) -> Value ( ) ;\n                if ( info . Length ( ) <= ( 7 ) || ! info [ 7 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"eighth\" \" argument to be \" \"a boolean\" ) ; bool deterministic = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 7 ] ) -> Value ( ) ;\n                if ( ! db -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( db -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( db -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::String::Utf8Value name(isolate, nameString);\n                auto xInverse = inverse->IsFunction() ? CustomAggregate::xInverse : NULL;\n                auto xValue = xInverse ? CustomAggregate::xValue : NULL;\n                int mask = deterministic ? SQLITE_UTF8 | SQLITE_DETERMINISTIC : SQLITE_UTF8;\n                safe_ints = safe_ints < 2 ? safe_ints : static_cast<int>(db->safe_ints);\n\n                if (sqlite3_create_window_function(db->db_handle, *name, argc, mask, new CustomAggregate(isolate, db, start, step, inverse, result, *name, safe_ints), CustomAggregate::xStep, CustomAggregate::xFinal, xValue, xInverse, CustomAggregate::xDestroy) != SQLITE_OK) {\n                        return db->ThrowDatabaseError();\n                }\n                info.GetReturnValue().Set(info.This());\n}\n#line 308 \"./src/objects/database.lzz\"\nvoid Database::JS_loadExtension (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 308 \"./src/objects/database.lzz\"\n                                      {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                v8::Local<v8::String> entryPoint;\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a string\" ) ; v8 :: Local < v8 :: String > filename = v8 :: Local < v8 :: String > :: Cast ( info [ 0 ] ) ;\n                if (info.Length() > 1) { if ( info . Length ( ) <= ( 1 ) || ! info [ 1 ] -> IsString ( ) ) return ThrowTypeError ( \"Expected \" \"second\" \" argument to be \" \"a string\" ) ; entryPoint = v8 :: Local < v8 :: String > :: Cast ( info [ 1 ] ) ; }\n                if ( ! db -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( db -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( db -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                char* error;\n                int status = sqlite3_load_extension(\n                        db->db_handle,\n                        *v8::String::Utf8Value(isolate, filename),\n                        entryPoint.IsEmpty() ? NULL : *v8::String::Utf8Value(isolate, entryPoint),\n                        &error\n                );\n                if (status == SQLITE_OK) info.GetReturnValue().Set(info.This());\n                else ThrowSqliteError(db->addon, error, status);\n                sqlite3_free(error);\n}\n#line 329 \"./src/objects/database.lzz\"\nvoid Database::JS_close (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 329 \"./src/objects/database.lzz\"\n                              {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                if (db->open) {\n                        if ( db -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                        if ( db -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                        db->addon->dbs.erase(db);\n                        db->CloseHandles();\n                }\n                info.GetReturnValue().Set(info.This());\n}\n#line 340 \"./src/objects/database.lzz\"\nvoid Database::JS_defaultSafeIntegers (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 340 \"./src/objects/database.lzz\"\n                                            {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                if (info.Length() == 0) db->safe_ints = true;\n                else { if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; db -> safe_ints = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ; }\n                info.GetReturnValue().Set(info.This());\n}\n#line 347 \"./src/objects/database.lzz\"\nvoid Database::JS_unsafeMode (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 347 \"./src/objects/database.lzz\"\n                                   {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                if (info.Length() == 0) db->unsafe_mode = true;\n                else { if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; db -> unsafe_mode = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ; }\n                sqlite3_db_config(db->db_handle, SQLITE_DBCONFIG_DEFENSIVE, static_cast<int>(!db->unsafe_mode), NULL);\n                info.GetReturnValue().Set(info.This());\n}\n#line 355 \"./src/objects/database.lzz\"\nvoid Database::JS_open (v8::Local <v8 :: String> _, v8::PropertyCallbackInfo <v8 :: Value> const & info)\n#line 355 \"./src/objects/database.lzz\"\n                             {\n                info.GetReturnValue().Set( node :: ObjectWrap :: Unwrap <Database>(info.This())->open);\n}\n#line 359 \"./src/objects/database.lzz\"\nvoid Database::JS_inTransaction (v8::Local <v8 :: String> _, v8::PropertyCallbackInfo <v8 :: Value> const & info)\n#line 359 \"./src/objects/database.lzz\"\n                                      {\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(info.This());\n                info.GetReturnValue().Set(db->open && !static_cast<bool>(sqlite3_get_autocommit(db->db_handle)));\n}\n#line 364 \"./src/objects/database.lzz\"\nint const Database::MAX_BUFFER_SIZE;\n#line 365 \"./src/objects/database.lzz\"\nint const Database::MAX_STRING_SIZE;\n#line 5 \"./src/objects/statement.lzz\"\nv8::Local <v8 :: Function> Statement::Init (v8::Isolate * isolate, v8::Local <v8 :: External> data)\n#line 5 \"./src/objects/statement.lzz\"\n                   {\n                v8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"Statement\");\n                SetPrototypeMethod(isolate, data, t, \"run\", JS_run);\n                SetPrototypeMethod(isolate, data, t, \"get\", JS_get);\n                SetPrototypeMethod(isolate, data, t, \"all\", JS_all);\n                SetPrototypeMethod(isolate, data, t, \"iterate\", JS_iterate);\n                SetPrototypeMethod(isolate, data, t, \"bind\", JS_bind);\n                SetPrototypeMethod(isolate, data, t, \"pluck\", JS_pluck);\n                SetPrototypeMethod(isolate, data, t, \"expand\", JS_expand);\n                SetPrototypeMethod(isolate, data, t, \"raw\", JS_raw);\n                SetPrototypeMethod(isolate, data, t, \"safeIntegers\", JS_safeIntegers);\n                SetPrototypeMethod(isolate, data, t, \"columns\", JS_columns);\n                return t->GetFunction( isolate -> GetCurrentContext ( ) ).ToLocalChecked();\n}\n#line 26 \"./src/objects/statement.lzz\"\nBindMap * Statement::GetBindMap (v8::Isolate * isolate)\n#line 26 \"./src/objects/statement.lzz\"\n                                                  {\n                if (has_bind_map) return &extras->bind_map;\n                BindMap* bind_map = &extras->bind_map;\n                int param_count = sqlite3_bind_parameter_count(handle);\n                for (int i=1; i<=param_count; ++i) {\n                        const char* name = sqlite3_bind_parameter_name(handle, i);\n                        if (name != NULL) bind_map->Add(isolate, name + 1, i);\n                }\n                has_bind_map = true;\n                return bind_map;\n}\n#line 39 \"./src/objects/statement.lzz\"\nvoid Statement::CloseHandles ()\n#line 39 \"./src/objects/statement.lzz\"\n                            {\n                if (alive) {\n                        alive = false;\n                        sqlite3_finalize(handle);\n                }\n}\n#line 46 \"./src/objects/statement.lzz\"\nStatement::~ Statement ()\n#line 46 \"./src/objects/statement.lzz\"\n                     {\n                if (alive) db->RemoveStatement(this);\n                CloseHandles();\n                delete extras;\n}\n#line 56 \"./src/objects/statement.lzz\"\nStatement::Extras::Extras (sqlite3_uint64 _id)\n#line 56 \"./src/objects/statement.lzz\"\n  : bind_map (0), id (_id)\n#line 56 \"./src/objects/statement.lzz\"\n                                                                           {}\n#line 61 \"./src/objects/statement.lzz\"\nStatement::Statement (Database * _db, sqlite3_stmt * _handle, sqlite3_uint64 _id, bool _returns_data)\n#line 61 \"./src/objects/statement.lzz\"\n  : node::ObjectWrap (), db (_db), handle (_handle), extras (new Extras(_id)), alive (true), locked (false), bound (false), has_bind_map (false), safe_ints (_db->GetState()->safe_ints), mode (Data::FLAT), returns_data (_returns_data)\n#line 71 \"./src/objects/statement.lzz\"\n                                            {\n                assert(db != NULL);\n                assert(handle != NULL);\n                assert(db->GetState()->open);\n                assert(!db->GetState()->busy);\n                db->AddStatement(this);\n}\n#line 79 \"./src/objects/statement.lzz\"\nvoid Statement::JS_new (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 79 \"./src/objects/statement.lzz\"\n                            {\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                if (!addon->privileged_info) {\n                        return ThrowTypeError(\"Statements can only be constructed by the db.prepare() method\");\n                }\n                assert(info.IsConstructCall());\n                v8::Local<v8::Object> database = addon->privileged_info->This();\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(database);\n                int flags = SQLITE_PREPARE_PERSISTENT;\n                if ( ! db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if (addon->PragmaMode()) {\n                        if ( ! db -> GetState ( ) -> unsafe_mode ) { if ( db -> GetState ( ) -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; } ( ( void ) 0 ) ;\n                        flags = 0;\n                }\n\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::Local<v8::String> source = v8::Local<v8::String>::Cast((*addon->privileged_info)[0]);\n                v8::String::Utf8Value utf8(isolate, source);\n                sqlite3_stmt* handle;\n                const char* tail;\n\n                if (sqlite3_prepare_v3(db->GetHandle(), *utf8, utf8.length() + 1, flags, &handle, &tail) != SQLITE_OK) {\n                        return db->ThrowDatabaseError();\n                }\n                if (handle == NULL) {\n                        return ThrowRangeError(\"The supplied SQL string contains no statements\");\n                }\n                for (char c; (c = *tail); ++tail) {\n                        if (IS_SKIPPED(c)) continue;\n                        if (c == '/' && tail[1] == '*') {\n                                tail += 2;\n                                for (char c; (c = *tail); ++tail) {\n                                        if (c == '*' && tail[1] == '/') {\n                                                tail += 1;\n                                                break;\n                                        }\n                                }\n                        } else if (c == '-' && tail[1] == '-') {\n                                tail += 2;\n                                for (char c; (c = *tail); ++tail) {\n                                        if (c == '\\n') break;\n                                }\n                        } else {\n                                sqlite3_finalize(handle);\n                                return ThrowRangeError(\"The supplied SQL string contains more than one statement\");\n                        }\n                }\n\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                bool returns_data = (sqlite3_stmt_readonly(handle) && sqlite3_column_count(handle) >= 1) || addon->PragmaMode();\n                Statement* stmt = new Statement(db, handle, addon->NextId(), returns_data);\n                stmt->Wrap(info.This());\n                SetFrozen(isolate, ctx, info.This(), addon->cs.reader, v8::Boolean::New(isolate, returns_data));\n                SetFrozen(isolate, ctx, info.This(), addon->cs.source, source);\n                SetFrozen(isolate, ctx, info.This(), addon->cs.database, database);\n\n                info.GetReturnValue().Set(info.This());\n}\n#line 139 \"./src/objects/statement.lzz\"\nvoid Statement::JS_run (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 139 \"./src/objects/statement.lzz\"\n                            {\n                Statement * stmt = node :: ObjectWrap :: Unwrap < Statement > ( info . This ( ) ) ; if ( stmt -> returns_data ) return ThrowTypeError ( \"This statement returns data. Use get(), all(), or iterate() instead\" ) ; sqlite3_stmt * handle = stmt -> handle ; Database * db = stmt -> db ; if ( ! db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ; if ( db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; assert ( ! stmt -> locked ) ; if ( ! db -> GetState ( ) -> unsafe_mode ) { if ( db -> GetState ( ) -> iterators ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; } ( ( void ) 0 ) ; const bool bound = stmt -> bound ; if ( ! bound ) { Binder binder ( handle ) ; if ( ! binder . Bind ( info , info . Length ( ) , stmt ) ) { sqlite3_clear_bindings ( handle ) ; return ; } ( ( void ) 0 ) ; } else if ( info . Length ( ) > 0 ) { return ThrowTypeError ( \"This statement already has bound parameters\" ) ; } ( ( void ) 0 ) ; db -> GetState ( ) -> busy = true ; v8 :: Isolate * isolate = info . GetIsolate ( ) ; if ( db -> Log ( isolate , handle ) ) { db -> GetState ( ) -> busy = false ; db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ; } ( ( void ) 0 ) ;\n                sqlite3* db_handle = db->GetHandle();\n                int total_changes_before = sqlite3_total_changes(db_handle);\n\n                sqlite3_step(handle);\n                if (sqlite3_reset(handle) == SQLITE_OK) {\n                        int changes = sqlite3_total_changes(db_handle) == total_changes_before ? 0 : sqlite3_changes(db_handle);\n                        sqlite3_int64 id = sqlite3_last_insert_rowid(db_handle);\n                        Addon* addon = db->GetAddon();\n                        v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                        v8::Local<v8::Object> result = v8::Object::New(isolate);\n                        result->Set(ctx, CS::Get(isolate, addon->cs.changes), v8::Int32::New(isolate, changes)).FromJust();\n                        result->Set(ctx, CS::Get(isolate, addon->cs.lastInsertRowid),\n                                stmt->safe_ints\n                                        ? v8::Local<v8::Value>::Cast(v8::BigInt::New(isolate, id))\n                                        : v8::Local<v8::Value>::Cast(v8::Number::New(isolate, (double)id))\n                        ).FromJust();\n                        db -> GetState ( ) -> busy = false ; info . GetReturnValue ( ) . Set ( result ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n                }\n                db -> GetState ( ) -> busy = false ; db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n}\n#line 162 \"./src/objects/statement.lzz\"\nvoid Statement::JS_get (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 162 \"./src/objects/statement.lzz\"\n                            {\n                Statement * stmt = node :: ObjectWrap :: Unwrap < Statement > ( info . This ( ) ) ; if ( ! stmt -> returns_data ) return ThrowTypeError ( \"This statement does not return data. Use run() instead\" ) ; sqlite3_stmt * handle = stmt -> handle ; Database * db = stmt -> db ; if ( ! db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ; if ( db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ; const bool bound = stmt -> bound ; if ( ! bound ) { Binder binder ( handle ) ; if ( ! binder . Bind ( info , info . Length ( ) , stmt ) ) { sqlite3_clear_bindings ( handle ) ; return ; } ( ( void ) 0 ) ; } else if ( info . Length ( ) > 0 ) { return ThrowTypeError ( \"This statement already has bound parameters\" ) ; } ( ( void ) 0 ) ; db -> GetState ( ) -> busy = true ; v8 :: Isolate * isolate = info . GetIsolate ( ) ; if ( db -> Log ( isolate , handle ) ) { db -> GetState ( ) -> busy = false ; db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ; } ( ( void ) 0 ) ;\n                int status = sqlite3_step(handle);\n                if (status == SQLITE_ROW) {\n                        v8::Local<v8::Value> result = Data::GetRowJS(isolate, isolate -> GetCurrentContext ( ) , handle, stmt->safe_ints, stmt->mode);\n                        sqlite3_reset(handle);\n                        db -> GetState ( ) -> busy = false ; info . GetReturnValue ( ) . Set ( result ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n                } else if (status == SQLITE_DONE) {\n                        sqlite3_reset(handle);\n                        db -> GetState ( ) -> busy = false ; info . GetReturnValue ( ) . Set ( v8 :: Undefined ( isolate ) ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n                }\n                sqlite3_reset(handle);\n                db -> GetState ( ) -> busy = false ; db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n}\n#line 177 \"./src/objects/statement.lzz\"\nvoid Statement::JS_all (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 177 \"./src/objects/statement.lzz\"\n                            {\n                Statement * stmt = node :: ObjectWrap :: Unwrap < Statement > ( info . This ( ) ) ; if ( ! stmt -> returns_data ) return ThrowTypeError ( \"This statement does not return data. Use run() instead\" ) ; sqlite3_stmt * handle = stmt -> handle ; Database * db = stmt -> db ; if ( ! db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ; if ( db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ; const bool bound = stmt -> bound ; if ( ! bound ) { Binder binder ( handle ) ; if ( ! binder . Bind ( info , info . Length ( ) , stmt ) ) { sqlite3_clear_bindings ( handle ) ; return ; } ( ( void ) 0 ) ; } else if ( info . Length ( ) > 0 ) { return ThrowTypeError ( \"This statement already has bound parameters\" ) ; } ( ( void ) 0 ) ; db -> GetState ( ) -> busy = true ; v8 :: Isolate * isolate = info . GetIsolate ( ) ; if ( db -> Log ( isolate , handle ) ) { db -> GetState ( ) -> busy = false ; db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ; } ( ( void ) 0 ) ;\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                v8::Local<v8::Array> result = v8::Array::New(isolate, 0);\n                uint32_t row_count = 0;\n                const bool safe_ints = stmt->safe_ints;\n                const char mode = stmt->mode;\n                bool js_error = false;\n\n                while (sqlite3_step(handle) == SQLITE_ROW) {\n                        if (row_count == 0xffffffff) { ThrowRangeError(\"Array overflow (too many rows returned)\"); js_error = true; break; }\n                        result->Set(ctx, row_count++, Data::GetRowJS(isolate, ctx, handle, safe_ints, mode)).FromJust();\n                }\n\n                if (sqlite3_reset(handle) == SQLITE_OK && !js_error) {\n                        db -> GetState ( ) -> busy = false ; info . GetReturnValue ( ) . Set ( result ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n                }\n                if (js_error) db->GetState()->was_js_error = true;\n                db -> GetState ( ) -> busy = false ; db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n}\n#line 198 \"./src/objects/statement.lzz\"\nvoid Statement::JS_iterate (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 198 \"./src/objects/statement.lzz\"\n                                {\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, addon->StatementIterator);\n                addon->privileged_info = &info;\n                v8::MaybeLocal<v8::Object> maybe_iter = c->NewInstance( isolate -> GetCurrentContext ( ) , 0, NULL);\n                addon->privileged_info = NULL;\n                if (!maybe_iter.IsEmpty()) info.GetReturnValue().Set(maybe_iter.ToLocalChecked());\n}\n#line 208 \"./src/objects/statement.lzz\"\nvoid Statement::JS_bind (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 208 \"./src/objects/statement.lzz\"\n                             {\n                Statement* stmt = node :: ObjectWrap :: Unwrap <Statement>(info.This());\n                if (stmt->bound) return ThrowTypeError(\"The bind() method can only be invoked once per statement object\");\n                if ( ! stmt -> db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( stmt -> db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ;\n                Binder binder ( stmt -> handle ) ; if ( ! binder . Bind ( info , info . Length ( ) , stmt ) ) { sqlite3_clear_bindings ( stmt -> handle ) ; return ; } ( ( void ) 0 ) ;\n                stmt->bound = true;\n                info.GetReturnValue().Set(info.This());\n}\n#line 219 \"./src/objects/statement.lzz\"\nvoid Statement::JS_pluck (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 219 \"./src/objects/statement.lzz\"\n                              {\n                Statement* stmt = node :: ObjectWrap :: Unwrap <Statement>(info.This());\n                if (!stmt->returns_data) return ThrowTypeError(\"The pluck() method is only for statements that return data\");\n                if ( stmt -> db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ;\n                bool use = true;\n                if (info.Length() != 0) { if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; use = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ; }\n                stmt->mode = use ? Data::PLUCK : stmt->mode == Data::PLUCK ? Data::FLAT : stmt->mode;\n                info.GetReturnValue().Set(info.This());\n}\n#line 230 \"./src/objects/statement.lzz\"\nvoid Statement::JS_expand (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 230 \"./src/objects/statement.lzz\"\n                               {\n                Statement* stmt = node :: ObjectWrap :: Unwrap <Statement>(info.This());\n                if (!stmt->returns_data) return ThrowTypeError(\"The expand() method is only for statements that return data\");\n                if ( stmt -> db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ;\n                bool use = true;\n                if (info.Length() != 0) { if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; use = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ; }\n                stmt->mode = use ? Data::EXPAND : stmt->mode == Data::EXPAND ? Data::FLAT : stmt->mode;\n                info.GetReturnValue().Set(info.This());\n}\n#line 241 \"./src/objects/statement.lzz\"\nvoid Statement::JS_raw (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 241 \"./src/objects/statement.lzz\"\n                            {\n                Statement* stmt = node :: ObjectWrap :: Unwrap <Statement>(info.This());\n                if (!stmt->returns_data) return ThrowTypeError(\"The raw() method is only for statements that return data\");\n                if ( stmt -> db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ;\n                bool use = true;\n                if (info.Length() != 0) { if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; use = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ; }\n                stmt->mode = use ? Data::RAW : stmt->mode == Data::RAW ? Data::FLAT : stmt->mode;\n                info.GetReturnValue().Set(info.This());\n}\n#line 252 \"./src/objects/statement.lzz\"\nvoid Statement::JS_safeIntegers (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 252 \"./src/objects/statement.lzz\"\n                                     {\n                Statement* stmt = node :: ObjectWrap :: Unwrap <Statement>(info.This());\n                if ( stmt -> db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ;\n                if (info.Length() == 0) stmt->safe_ints = true;\n                else { if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsBoolean ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a boolean\" ) ; stmt -> safe_ints = v8 :: Local < v8 :: Boolean > :: Cast ( info [ 0 ] ) -> Value ( ) ; }\n                info.GetReturnValue().Set(info.This());\n}\n#line 261 \"./src/objects/statement.lzz\"\nvoid Statement::JS_columns (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 261 \"./src/objects/statement.lzz\"\n                                {\n                Statement* stmt = node :: ObjectWrap :: Unwrap <Statement>(info.This());\n                if (!stmt->returns_data) return ThrowTypeError(\"The columns() method is only for statements that return data\");\n                if ( ! stmt -> db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( stmt -> db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                Addon* addon = stmt->db->GetAddon();\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n\n                int column_count = sqlite3_column_count(stmt->handle);\n                v8::Local<v8::Array> columns = v8::Array::New(isolate);\n\n                v8::Local<v8::String> name = CS::Get(isolate, addon->cs.name);\n                v8::Local<v8::String> columnName = CS::Get(isolate, addon->cs.column);\n                v8::Local<v8::String> tableName = CS::Get(isolate, addon->cs.table);\n                v8::Local<v8::String> databaseName = CS::Get(isolate, addon->cs.database);\n                v8::Local<v8::String> typeName = CS::Get(isolate, addon->cs.type);\n\n                for (int i=0; i<column_count; ++i) {\n                        v8::Local<v8::Object> column = v8::Object::New(isolate);\n\n                        column->Set(ctx, name,\n                                InternalizedFromUtf8OrNull(isolate, sqlite3_column_name(stmt->handle, i), -1)\n                        ).FromJust();\n                        column->Set(ctx, columnName,\n                                InternalizedFromUtf8OrNull(isolate, sqlite3_column_origin_name(stmt->handle, i), -1)\n                        ).FromJust();\n                        column->Set(ctx, tableName,\n                                InternalizedFromUtf8OrNull(isolate, sqlite3_column_table_name(stmt->handle, i), -1)\n                        ).FromJust();\n                        column->Set(ctx, databaseName,\n                                InternalizedFromUtf8OrNull(isolate, sqlite3_column_database_name(stmt->handle, i), -1)\n                        ).FromJust();\n                        column->Set(ctx, typeName,\n                                InternalizedFromUtf8OrNull(isolate, sqlite3_column_decltype(stmt->handle, i), -1)\n                        ).FromJust();\n\n                        columns->Set(ctx, i, column).FromJust();\n                }\n\n                info.GetReturnValue().Set(columns);\n}\n#line 4 \"./src/objects/statement-iterator.lzz\"\nv8::Local <v8 :: Function> StatementIterator::Init (v8::Isolate * isolate, v8::Local <v8 :: External> data)\n#line 4 \"./src/objects/statement-iterator.lzz\"\n                   {\n                v8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"StatementIterator\");\n                SetPrototypeMethod(isolate, data, t, \"next\", JS_next);\n                SetPrototypeMethod(isolate, data, t, \"return\", JS_return);\n                SetPrototypeSymbolMethod(isolate, data, t, v8::Symbol::GetIterator(isolate), JS_symbolIterator);\n                return t->GetFunction( isolate -> GetCurrentContext ( ) ).ToLocalChecked();\n}\n#line 15 \"./src/objects/statement-iterator.lzz\"\nStatementIterator::~ StatementIterator ()\n#line 15 \"./src/objects/statement-iterator.lzz\"\n                             {}\n#line 19 \"./src/objects/statement-iterator.lzz\"\nStatementIterator::StatementIterator (Statement * _stmt, bool _bound)\n#line 19 \"./src/objects/statement-iterator.lzz\"\n  : node::ObjectWrap (), stmt (_stmt), handle (_stmt->handle), db_state (_stmt->db->GetState()), bound (_bound), safe_ints (_stmt->safe_ints), mode (_stmt->mode), alive (true), logged (!db_state->has_logger)\n#line 27 \"./src/objects/statement-iterator.lzz\"\n                                              {\n                assert(stmt != NULL);\n                assert(handle != NULL);\n                assert(stmt->bound == bound);\n                assert(stmt->alive == true);\n                assert(stmt->locked == false);\n                assert(db_state->iterators < USHRT_MAX);\n                stmt->locked = true;\n                db_state->iterators += 1;\n}\n#line 38 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::JS_new (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 38 \"./src/objects/statement-iterator.lzz\"\n                            {\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                if (!addon->privileged_info) return ThrowTypeError(\"Disabled constructor\");\n                assert(info.IsConstructCall());\n\n                StatementIterator* iter;\n                {\n                        const v8 :: FunctionCallbackInfo < v8 :: Value > & info = *addon->privileged_info;\n                        Statement * stmt = node :: ObjectWrap :: Unwrap < Statement > ( info . This ( ) ) ; if ( ! stmt -> returns_data ) return ThrowTypeError ( \"This statement does not return data. Use run() instead\" ) ; sqlite3_stmt * handle = stmt -> handle ; Database * db = stmt -> db ; if ( ! db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ; if ( db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ; if ( stmt -> locked ) return ThrowTypeError ( \"This statement is busy executing a query\" ) ; if ( db -> GetState ( ) -> iterators == USHRT_MAX ) return ThrowRangeError ( \"Too many active database iterators\" ) ; const bool bound = stmt -> bound ; if ( ! bound ) { Binder binder ( handle ) ; if ( ! binder . Bind ( info , info . Length ( ) , stmt ) ) { sqlite3_clear_bindings ( handle ) ; return ; } ( ( void ) 0 ) ; } else if ( info . Length ( ) > 0 ) { return ThrowTypeError ( \"This statement already has bound parameters\" ) ; } ( ( void ) 0 ) ;\n                        iter = new StatementIterator(stmt, bound);\n                }\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                iter->Wrap(info.This());\n                SetFrozen(isolate, ctx, info.This(), addon->cs.statement, addon->privileged_info->This());\n\n                info.GetReturnValue().Set(info.This());\n}\n#line 57 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::JS_next (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 57 \"./src/objects/statement-iterator.lzz\"\n                             {\n                StatementIterator* iter = node :: ObjectWrap :: Unwrap <StatementIterator>(info.This());\n                if ( iter -> db_state -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if (iter->alive) iter->Next(info);\n                else info.GetReturnValue().Set(DoneRecord( info . GetIsolate ( ) , iter->db_state->addon));\n}\n#line 64 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::JS_return (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 64 \"./src/objects/statement-iterator.lzz\"\n                               {\n                StatementIterator* iter = node :: ObjectWrap :: Unwrap <StatementIterator>(info.This());\n                if ( iter -> db_state -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n                if (iter->alive) iter->Return(info);\n                else info.GetReturnValue().Set(DoneRecord( info . GetIsolate ( ) , iter->db_state->addon));\n}\n#line 71 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::JS_symbolIterator (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 71 \"./src/objects/statement-iterator.lzz\"\n                                       {\n                info.GetReturnValue().Set(info.This());\n}\n#line 75 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::Next (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 75 \"./src/objects/statement-iterator.lzz\"\n                                       {\n                assert(alive == true);\n                db_state->busy = true;\n                if (!logged) {\n                        logged = true;\n                        if (stmt->db->Log( info . GetIsolate ( ) , handle)) {\n                                db_state->busy = false;\n                                Throw();\n                                return;\n                        }\n                }\n                int status = sqlite3_step(handle);\n                db_state->busy = false;\n                if (status == SQLITE_ROW) {\n                        v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                        v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                        info.GetReturnValue().Set(\n                                NewRecord(isolate, ctx, Data::GetRowJS(isolate, ctx, handle, safe_ints, mode), db_state->addon, false)\n                        );\n                } else {\n                        if (status == SQLITE_DONE) Return(info);\n                        else Throw();\n                }\n}\n#line 100 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::Return (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 100 \"./src/objects/statement-iterator.lzz\"\n                                         {\n                Cleanup();\n                info . GetReturnValue ( ) . Set ( DoneRecord ( info . GetIsolate ( ) , db_state -> addon ) ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n}\n#line 105 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::Throw ()\n#line 105 \"./src/objects/statement-iterator.lzz\"\n                     {\n                Cleanup();\n                Database* db = stmt->db;\n                db -> ThrowDatabaseError ( ) ; if ( ! bound ) { sqlite3_clear_bindings ( handle ) ; } return ;\n}\n#line 111 \"./src/objects/statement-iterator.lzz\"\nvoid StatementIterator::Cleanup ()\n#line 111 \"./src/objects/statement-iterator.lzz\"\n                       {\n                assert(alive == true);\n                alive = false;\n                stmt->locked = false;\n                db_state->iterators -= 1;\n                sqlite3_reset(handle);\n}\n#line 4 \"./src/objects/backup.lzz\"\nv8::Local <v8 :: Function> Backup::Init (v8::Isolate * isolate, v8::Local <v8 :: External> data)\n#line 4 \"./src/objects/backup.lzz\"\n                   {\n                v8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"Backup\");\n                SetPrototypeMethod(isolate, data, t, \"transfer\", JS_transfer);\n                SetPrototypeMethod(isolate, data, t, \"close\", JS_close);\n                return t->GetFunction( isolate -> GetCurrentContext ( ) ).ToLocalChecked();\n}\n#line 17 \"./src/objects/backup.lzz\"\nvoid Backup::CloseHandles ()\n#line 17 \"./src/objects/backup.lzz\"\n                            {\n                if (alive) {\n                        alive = false;\n                        std::string filename(sqlite3_db_filename(dest_handle, \"main\"));\n                        sqlite3_backup_finish(backup_handle);\n                        int status = sqlite3_close(dest_handle);\n                        assert(status == SQLITE_OK); ((void)status);\n                        if (unlink) remove(filename.c_str());\n                }\n}\n#line 29 \"./src/objects/backup.lzz\"\nBackup::~ Backup ()\n#line 29 \"./src/objects/backup.lzz\"\n                  {\n                if (alive) db->RemoveBackup(this);\n                CloseHandles();\n}\n#line 36 \"./src/objects/backup.lzz\"\nBackup::Backup (Database * _db, sqlite3 * _dest_handle, sqlite3_backup * _backup_handle, sqlite3_uint64 _id, bool _unlink)\n#line 36 \"./src/objects/backup.lzz\"\n  : node::ObjectWrap (), db (_db), dest_handle (_dest_handle), backup_handle (_backup_handle), id (_id), alive (true), unlink (_unlink)\n#line 42 \"./src/objects/backup.lzz\"\n                                {\n                assert(db != NULL);\n                assert(dest_handle != NULL);\n                assert(backup_handle != NULL);\n                db->AddBackup(this);\n}\n#line 49 \"./src/objects/backup.lzz\"\nvoid Backup::JS_new (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 49 \"./src/objects/backup.lzz\"\n                            {\n                Addon * addon = static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ;\n                if (!addon->privileged_info) return ThrowTypeError(\"Disabled constructor\");\n                assert(info.IsConstructCall());\n                v8::Local<v8::Object> database = addon->privileged_info->This();\n                Database* db = node :: ObjectWrap :: Unwrap <Database>(database);\n                if ( ! db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                if ( db -> GetState ( ) -> busy ) return ThrowTypeError ( \"This database connection is busy executing a query\" ) ;\n\n                v8::Local<v8::String> attachedName = v8::Local<v8::String>::Cast((*addon->privileged_info)[0]);\n                v8::Local<v8::String> destFile = v8::Local<v8::String>::Cast((*addon->privileged_info)[1]);\n                bool unlink = v8::Local<v8::Boolean>::Cast((*addon->privileged_info)[2])->Value();\n\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                sqlite3* dest_handle;\n                v8::String::Utf8Value dest_file(isolate, destFile);\n                v8::String::Utf8Value attached_name(isolate, attachedName);\n                int mask = (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);\n\n                if (sqlite3_open_v2(*dest_file, &dest_handle, mask, NULL) != SQLITE_OK) {\n                        Database::ThrowSqliteError(addon, dest_handle);\n                        int status = sqlite3_close(dest_handle);\n                        assert(status == SQLITE_OK); ((void)status);\n                        return;\n                }\n\n                sqlite3_extended_result_codes(dest_handle, 1);\n                sqlite3_limit(dest_handle, SQLITE_LIMIT_LENGTH, INT_MAX);\n                sqlite3_backup* backup_handle = sqlite3_backup_init(dest_handle, \"main\", db->GetHandle(), *attached_name);\n                if (backup_handle == NULL) {\n                        Database::ThrowSqliteError(addon, dest_handle);\n                        int status = sqlite3_close(dest_handle);\n                        assert(status == SQLITE_OK); ((void)status);\n                        return;\n                }\n\n                Backup* backup = new Backup(db, dest_handle, backup_handle, addon->NextId(), unlink);\n                backup->Wrap(info.This());\n                SetFrozen(isolate, isolate -> GetCurrentContext ( ) , info.This(), addon->cs.database, database);\n\n                info.GetReturnValue().Set(info.This());\n}\n#line 92 \"./src/objects/backup.lzz\"\nvoid Backup::JS_transfer (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 92 \"./src/objects/backup.lzz\"\n                                 {\n                Backup* backup = node :: ObjectWrap :: Unwrap <Backup>(info.This());\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsInt32 ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a 32-bit signed integer\" ) ; int pages = v8 :: Local < v8 :: Int32 > :: Cast ( info [ 0 ] ) -> Value ( ) ;\n                if ( ! backup -> db -> GetState ( ) -> open ) return ThrowTypeError ( \"The database connection is not open\" ) ;\n                assert(backup->db->GetState()->busy == false);\n                assert(backup->alive == true);\n\n                sqlite3_backup* backup_handle = backup->backup_handle;\n                int status = sqlite3_backup_step(backup_handle, pages) & 0xff;\n\n                Addon* addon = backup->db->GetAddon();\n                if (status == SQLITE_OK || status == SQLITE_DONE || status == SQLITE_BUSY) {\n                        int total_pages = sqlite3_backup_pagecount(backup_handle);\n                        int remaining_pages = sqlite3_backup_remaining(backup_handle);\n                        v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                        v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                        v8::Local<v8::Object> result = v8::Object::New(isolate);\n                        result->Set(ctx, CS::Get(isolate, addon->cs.totalPages), v8::Int32::New(isolate, total_pages)).FromJust();\n                        result->Set(ctx, CS::Get(isolate, addon->cs.remainingPages), v8::Int32::New(isolate, remaining_pages)).FromJust();\n                        info.GetReturnValue().Set(result);\n                        if (status == SQLITE_DONE) backup->unlink = false;\n                } else {\n                        Database::ThrowSqliteError(addon, sqlite3_errstr(status), status);\n                }\n}\n#line 118 \"./src/objects/backup.lzz\"\nvoid Backup::JS_close (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 118 \"./src/objects/backup.lzz\"\n                              {\n                Backup* backup = node :: ObjectWrap :: Unwrap <Backup>(info.This());\n                assert(backup->db->GetState()->busy == false);\n                if (backup->alive) backup->db->RemoveBackup(backup);\n                backup->CloseHandles();\n                info.GetReturnValue().Set(info.This());\n}\n#line 4 \"./src/util/custom-function.lzz\"\nCustomFunction::CustomFunction (v8::Isolate * _isolate, Database * _db, v8::Local <v8::Function> _fn, char const * _name, bool _safe_ints)\n#line 5 \"./src/util/custom-function.lzz\"\n  : name (COPY(_name)), db (_db), isolate (_isolate), fn (_isolate, _fn), safe_ints (_safe_ints)\n#line 5 \"./src/util/custom-function.lzz\"\n                                                                                                          {}\n#line 6 \"./src/util/custom-function.lzz\"\nCustomFunction::~ CustomFunction ()\n#line 6 \"./src/util/custom-function.lzz\"\n                                  { delete[] name;\n}\n#line 8 \"./src/util/custom-function.lzz\"\nvoid CustomFunction::xDestroy (void * self)\n#line 8 \"./src/util/custom-function.lzz\"\n                                         {\n                delete static_cast<CustomFunction*>(self);\n}\n#line 12 \"./src/util/custom-function.lzz\"\nvoid CustomFunction::xFunc (sqlite3_context * invocation, int argc, sqlite3_value * * argv)\n#line 12 \"./src/util/custom-function.lzz\"\n                                                                                       {\n                CustomFunction * self = static_cast < CustomFunction * > ( sqlite3_user_data ( invocation ) ) ; v8 :: Isolate * isolate = self -> isolate ; v8 :: HandleScope scope ( isolate ) ;\n\n                v8::Local<v8::Value> args_fast[4];\n                v8::Local<v8::Value>* args = NULL;\n                if (argc != 0) {\n                        args = argc <= 4 ? args_fast : ALLOC_ARRAY<v8::Local<v8::Value>>(argc);\n                        Data::GetArgumentsJS(isolate, args, argv, argc, self->safe_ints);\n                }\n\n                v8::MaybeLocal<v8::Value> maybe_return_value = v8::Local<v8::Function>::New(isolate, self->fn)->Call( isolate -> GetCurrentContext ( ) , v8::Undefined(isolate), argc, args);\n                if (args != args_fast) delete[] args;\n\n                if (maybe_return_value.IsEmpty()) self->PropagateJSError(invocation);\n                else Data::ResultValueFromJS(isolate, invocation, maybe_return_value.ToLocalChecked(), self);\n}\n#line 29 \"./src/util/custom-function.lzz\"\nvoid CustomFunction::ThrowResultValueError (sqlite3_context * invocation, bool isBigInt)\n#line 29 \"./src/util/custom-function.lzz\"\n                                                                               {\n                if (isBigInt) {\n                        ThrowRangeError(CONCAT(\"User-defined function \", name, \"() returned a bigint that was too big\").c_str());\n                } else {\n                        ThrowTypeError(CONCAT(\"User-defined function \", name, \"() returned an invalid value\").c_str());\n                }\n                PropagateJSError(invocation);\n}\n#line 39 \"./src/util/custom-function.lzz\"\nvoid CustomFunction::PropagateJSError (sqlite3_context * invocation)\n#line 39 \"./src/util/custom-function.lzz\"\n                                                                   {\n                assert(db->GetState()->was_js_error == false);\n                db->GetState()->was_js_error = true;\n                sqlite3_result_error(invocation, \"\", 0);\n}\n#line 4 \"./src/util/custom-aggregate.lzz\"\nCustomAggregate::CustomAggregate (v8::Isolate * _isolate, Database * _db, v8::Local <v8::Value> _start, v8::Local <v8::Function> _step, v8::Local <v8::Value> _inverse, v8::Local <v8::Value> _result, char const * _name, bool _safe_ints)\n#line 5 \"./src/util/custom-aggregate.lzz\"\n  : CustomFunction (_isolate, _db, _step, _name, _safe_ints), invoke_result (_result->IsFunction()), invoke_start (_start->IsFunction()), inverse (_isolate, _inverse->IsFunction() ? v8::Local<v8::Function>::Cast(_inverse) : v8::Local<v8::Function>()), result (_isolate, _result->IsFunction() ? v8::Local<v8::Function>::Cast(_result) : v8::Local<v8::Function>()), start (_isolate, _start)\n#line 5 \"./src/util/custom-aggregate.lzz\"\n                                                                                                                                                                                                                                                                                                                                                                                                            {}\n#line 7 \"./src/util/custom-aggregate.lzz\"\nvoid CustomAggregate::xStep (sqlite3_context * invocation, int argc, sqlite3_value * * argv)\n#line 7 \"./src/util/custom-aggregate.lzz\"\n                                                                                       {\n                xStepBase(invocation, argc, argv, &CustomAggregate::fn);\n}\n#line 11 \"./src/util/custom-aggregate.lzz\"\nvoid CustomAggregate::xInverse (sqlite3_context * invocation, int argc, sqlite3_value * * argv)\n#line 11 \"./src/util/custom-aggregate.lzz\"\n                                                                                          {\n                xStepBase(invocation, argc, argv, &CustomAggregate::inverse);\n}\n#line 15 \"./src/util/custom-aggregate.lzz\"\nvoid CustomAggregate::xValue (sqlite3_context * invocation)\n#line 15 \"./src/util/custom-aggregate.lzz\"\n                                                        {\n                xValueBase(invocation, false);\n}\n#line 19 \"./src/util/custom-aggregate.lzz\"\nvoid CustomAggregate::xFinal (sqlite3_context * invocation)\n#line 19 \"./src/util/custom-aggregate.lzz\"\n                                                        {\n                xValueBase(invocation, true);\n}\n#line 73 \"./src/util/custom-aggregate.lzz\"\nCustomAggregate::Accumulator * CustomAggregate::GetAccumulator (sqlite3_context * invocation)\n#line 73 \"./src/util/custom-aggregate.lzz\"\n                                                                 {\n                Accumulator* acc = static_cast<Accumulator*>(sqlite3_aggregate_context(invocation, sizeof(Accumulator)));\n                if (!acc->initialized) {\n                        assert(acc->value.IsEmpty());\n                        acc->initialized = true;\n                        if (invoke_start) {\n                                v8::MaybeLocal<v8::Value> maybe_seed = v8::Local<v8::Function>::Cast(v8::Local<v8::Value>::New(isolate, start))->Call( isolate -> GetCurrentContext ( ) , v8::Undefined(isolate), 0, NULL);\n                                if (maybe_seed.IsEmpty()) PropagateJSError(invocation);\n                                else acc->value.Reset(isolate, maybe_seed.ToLocalChecked());\n                        } else {\n                                assert(!start.IsEmpty());\n                                acc->value.Reset(isolate, start);\n                        }\n                }\n                return acc;\n}\n#line 90 \"./src/util/custom-aggregate.lzz\"\nvoid CustomAggregate::DestroyAccumulator (sqlite3_context * invocation)\n#line 90 \"./src/util/custom-aggregate.lzz\"\n                                                                    {\n                Accumulator* acc = static_cast<Accumulator*>(sqlite3_aggregate_context(invocation, sizeof(Accumulator)));\n                assert(acc->initialized);\n                acc->value.Reset();\n}\n#line 96 \"./src/util/custom-aggregate.lzz\"\nvoid CustomAggregate::PropagateJSError (sqlite3_context * invocation)\n#line 96 \"./src/util/custom-aggregate.lzz\"\n                                                           {\n                DestroyAccumulator(invocation);\n                CustomFunction::PropagateJSError(invocation);\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 74 \"./src/util/data.lzz\"\n  v8::Local <v8::Value> GetValueJS (v8::Isolate * isolate, sqlite3_stmt * handle, int column, bool safe_ints)\n#line 74 \"./src/util/data.lzz\"\n                                                                                                                {\n                switch ( sqlite3_column_type ( handle , column ) ) { case SQLITE_INTEGER : if ( safe_ints ) { return v8 :: BigInt :: New ( isolate , sqlite3_column_int64 ( handle , column ) ) ; } case SQLITE_FLOAT : return v8 :: Number :: New ( isolate , sqlite3_column_double ( handle , column ) ) ; case SQLITE_TEXT : return StringFromUtf8 ( isolate , reinterpret_cast < const char * > ( sqlite3_column_text ( handle , column ) ) , sqlite3_column_bytes ( handle , column ) ) ; case SQLITE_BLOB : return node :: Buffer :: Copy ( isolate , static_cast < const char * > ( sqlite3_column_blob ( handle , column ) ) , sqlite3_column_bytes ( handle , column ) ) . ToLocalChecked ( ) ; default : assert ( sqlite3_column_type ( handle , column ) == SQLITE_NULL ) ; return v8 :: Null ( isolate ) ; } assert ( false ) ; ;\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 78 \"./src/util/data.lzz\"\n  v8::Local <v8::Value> GetValueJS (v8::Isolate * isolate, sqlite3_value * value, bool safe_ints)\n#line 78 \"./src/util/data.lzz\"\n                                                                                                    {\n                switch ( sqlite3_value_type ( value ) ) { case SQLITE_INTEGER : if ( safe_ints ) { return v8 :: BigInt :: New ( isolate , sqlite3_value_int64 ( value ) ) ; } case SQLITE_FLOAT : return v8 :: Number :: New ( isolate , sqlite3_value_double ( value ) ) ; case SQLITE_TEXT : return StringFromUtf8 ( isolate , reinterpret_cast < const char * > ( sqlite3_value_text ( value ) ) , sqlite3_value_bytes ( value ) ) ; case SQLITE_BLOB : return node :: Buffer :: Copy ( isolate , static_cast < const char * > ( sqlite3_value_blob ( value ) ) , sqlite3_value_bytes ( value ) ) . ToLocalChecked ( ) ; default : assert ( sqlite3_value_type ( value ) == SQLITE_NULL ) ; return v8 :: Null ( isolate ) ; } assert ( false ) ; ;\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 82 \"./src/util/data.lzz\"\n  v8::Local <v8::Value> GetFlatRowJS (v8::Isolate * isolate, v8::Local <v8::Context> ctx, sqlite3_stmt * handle, bool safe_ints)\n#line 82 \"./src/util/data.lzz\"\n                                                                                                                                  {\n                v8::Local<v8::Object> row = v8::Object::New(isolate);\n                int column_count = sqlite3_column_count(handle);\n                for (int i=0; i<column_count; ++i) {\n                        row->Set(ctx,\n                                InternalizedFromUtf8(isolate, sqlite3_column_name(handle, i), -1),\n                                Data::GetValueJS(isolate, handle, i, safe_ints)).FromJust();\n                }\n                return row;\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 93 \"./src/util/data.lzz\"\n  v8::Local <v8::Value> GetExpandedRowJS (v8::Isolate * isolate, v8::Local <v8::Context> ctx, sqlite3_stmt * handle, bool safe_ints)\n#line 93 \"./src/util/data.lzz\"\n                                                                                                                                      {\n                v8::Local<v8::Object> row = v8::Object::New(isolate);\n                int column_count = sqlite3_column_count(handle);\n                for (int i=0; i<column_count; ++i) {\n                        const char* table_raw = sqlite3_column_table_name(handle, i);\n                        v8::Local<v8::String> table = InternalizedFromUtf8(isolate, table_raw == NULL ? \"$\" : table_raw, -1);\n                        v8::Local<v8::String> column = InternalizedFromUtf8(isolate, sqlite3_column_name(handle, i), -1);\n                        v8::Local<v8::Value> value = Data::GetValueJS(isolate, handle, i, safe_ints);\n                        if (row->HasOwnProperty(ctx, table).FromJust()) {\n                                v8::Local<v8::Object>::Cast(row->Get(ctx, table).ToLocalChecked())->Set(ctx, column, value).FromJust();\n                        } else {\n                                v8::Local<v8::Object> nested = v8::Object::New(isolate);\n                                row->Set(ctx, table, nested).FromJust();\n                                nested->Set(ctx, column, value).FromJust();\n                        }\n                }\n                return row;\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 112 \"./src/util/data.lzz\"\n  v8::Local <v8::Value> GetRawRowJS (v8::Isolate * isolate, v8::Local <v8::Context> ctx, sqlite3_stmt * handle, bool safe_ints)\n#line 112 \"./src/util/data.lzz\"\n                                                                                                                                 {\n                v8::Local<v8::Array> row = v8::Array::New(isolate);\n                int column_count = sqlite3_column_count(handle);\n                for (int i=0; i<column_count; ++i) {\n                        row->Set(ctx, i, Data::GetValueJS(isolate, handle, i, safe_ints)).FromJust();\n                }\n                return row;\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 121 \"./src/util/data.lzz\"\n  v8::Local <v8::Value> GetRowJS (v8::Isolate * isolate, v8::Local <v8::Context> ctx, sqlite3_stmt * handle, bool safe_ints, char mode)\n#line 121 \"./src/util/data.lzz\"\n                                                                                                                                         {\n                if (mode == FLAT) return GetFlatRowJS(isolate, ctx, handle, safe_ints);\n                if (mode == PLUCK) return GetValueJS(isolate, handle, 0, safe_ints);\n                if (mode == EXPAND) return GetExpandedRowJS(isolate, ctx, handle, safe_ints);\n                if (mode == RAW) return GetRawRowJS(isolate, ctx, handle, safe_ints);\n                assert(false);\n                return v8::Local<v8::Value>();\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 130 \"./src/util/data.lzz\"\n  void GetArgumentsJS (v8::Isolate * isolate, v8::Local <v8::Value> * out, sqlite3_value * * values, int argument_count, bool safe_ints)\n#line 130 \"./src/util/data.lzz\"\n                                                                                                                                         {\n                assert(argument_count > 0);\n                for (int i=0; i<argument_count; ++i) {\n                        out[i] = Data::GetValueJS(isolate, values[i], safe_ints);\n                }\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 137 \"./src/util/data.lzz\"\n  int BindValueFromJS (v8::Isolate * isolate, sqlite3_stmt * handle, int index, v8::Local <v8::Value> value)\n#line 137 \"./src/util/data.lzz\"\n                                                                                                               {\n                if ( value -> IsNumber ( ) ) { return sqlite3_bind_double ( handle , index , v8 :: Local < v8 :: Number > :: Cast ( value ) -> Value ( ) ) ; } else if ( value -> IsBigInt ( ) ) { bool lossless ; int64_t v = v8 :: Local < v8 :: BigInt > :: Cast ( value ) -> Int64Value ( & lossless ) ; if ( lossless ) { return sqlite3_bind_int64 ( handle , index , v ) ; } } else if ( value -> IsString ( ) ) { v8 :: String :: Utf8Value utf8 ( isolate , v8 :: Local < v8 :: String > :: Cast ( value ) ) ; return sqlite3_bind_text ( handle , index , * utf8 , utf8 . length ( ) , SQLITE_TRANSIENT ) ; } else if ( node :: Buffer :: HasInstance ( value ) ) { return sqlite3_bind_blob ( handle , index , node :: Buffer :: Data ( value ) , node :: Buffer :: Length ( value ) , SQLITE_TRANSIENT ) ; } else if ( value -> IsNull ( ) || value -> IsUndefined ( ) ) { return sqlite3_bind_null ( handle , index ) ; } ;\n                return value->IsBigInt() ? SQLITE_TOOBIG : -1;\n  }\n}\n#line 67 \"./src/util/data.lzz\"\nnamespace Data\n{\n#line 142 \"./src/util/data.lzz\"\n  void ResultValueFromJS (v8::Isolate * isolate, sqlite3_context * invocation, v8::Local <v8::Value> value, CustomFunction * function)\n#line 142 \"./src/util/data.lzz\"\n                                                                                                                                        {\n                if ( value -> IsNumber ( ) ) { return sqlite3_result_double ( invocation , v8 :: Local < v8 :: Number > :: Cast ( value ) -> Value ( ) ) ; } else if ( value -> IsBigInt ( ) ) { bool lossless ; int64_t v = v8 :: Local < v8 :: BigInt > :: Cast ( value ) -> Int64Value ( & lossless ) ; if ( lossless ) { return sqlite3_result_int64 ( invocation , v ) ; } } else if ( value -> IsString ( ) ) { v8 :: String :: Utf8Value utf8 ( isolate , v8 :: Local < v8 :: String > :: Cast ( value ) ) ; return sqlite3_result_text ( invocation , * utf8 , utf8 . length ( ) , SQLITE_TRANSIENT ) ; } else if ( node :: Buffer :: HasInstance ( value ) ) { return sqlite3_result_blob ( invocation , node :: Buffer :: Data ( value ) , node :: Buffer :: Length ( value ) , SQLITE_TRANSIENT ) ; } else if ( value -> IsNull ( ) || value -> IsUndefined ( ) ) { return sqlite3_result_null ( invocation ) ; } ;\n                function->ThrowResultValueError(invocation, value->IsBigInt());\n  }\n}\n#line 4 \"./src/util/binder.lzz\"\nBinder::Binder (sqlite3_stmt * _handle)\n#line 4 \"./src/util/binder.lzz\"\n                                               {\n                handle = _handle;\n                param_count = sqlite3_bind_parameter_count(_handle);\n                anon_index = 0;\n                success = true;\n}\n#line 11 \"./src/util/binder.lzz\"\nbool Binder::Bind (v8::FunctionCallbackInfo <v8 :: Value> const & info, int argc, Statement * stmt)\n#line 11 \"./src/util/binder.lzz\"\n                                                                  {\n                assert(anon_index == 0);\n                Result result = BindArgs(info, argc, stmt);\n                if (success && result.count != param_count) {\n                        if (result.count < param_count) {\n                                if (!result.bound_object && stmt->GetBindMap( info . GetIsolate ( ) )->GetSize()) {\n                                        Fail(ThrowTypeError, \"Missing named parameters\");\n                                } else {\n                                        Fail(ThrowRangeError, \"Too few parameter values were provided\");\n                                }\n                        } else {\n                                Fail(ThrowRangeError, \"Too many parameter values were provided\");\n                        }\n                }\n                return success;\n}\n#line 34 \"./src/util/binder.lzz\"\nbool Binder::IsPlainObject (v8::Isolate * isolate, v8::Local <v8::Object> obj)\n#line 34 \"./src/util/binder.lzz\"\n                                                                                   {\n                v8::Local<v8::Value> proto = obj->GetPrototype();\n                v8::Local<v8::Context> ctx = obj->CreationContext();\n                ctx->Enter();\n                v8::Local<v8::Value> baseProto = v8::Object::New(isolate)->GetPrototype();\n                ctx->Exit();\n                return proto->StrictEquals(baseProto) || proto->StrictEquals(v8::Null(isolate));\n}\n#line 43 \"./src/util/binder.lzz\"\nvoid Binder::Fail (void (* Throw) (char const *), char const * message)\n#line 43 \"./src/util/binder.lzz\"\n                                                                     {\n                assert(success == true);\n                assert((Throw == NULL) == (message == NULL));\n                assert(Throw == ThrowError || Throw == ThrowTypeError || Throw == ThrowRangeError || Throw == NULL);\n                if (Throw) Throw(message);\n                success = false;\n}\n#line 51 \"./src/util/binder.lzz\"\nint Binder::NextAnonIndex ()\n#line 51 \"./src/util/binder.lzz\"\n                            {\n                while (sqlite3_bind_parameter_name(handle, ++anon_index) != NULL) {}\n                return anon_index;\n}\n#line 57 \"./src/util/binder.lzz\"\nvoid Binder::BindValue (v8::Isolate * isolate, v8::Local <v8::Value> value, int index)\n#line 57 \"./src/util/binder.lzz\"\n                                                                                    {\n                int status = Data::BindValueFromJS(isolate, handle, index, value);\n                if (status != SQLITE_OK) {\n                        switch (status) {\n                                case -1:\n                                        return Fail(ThrowTypeError, \"SQLite3 can only bind numbers, strings, bigints, buffers, and null\");\n                                case SQLITE_TOOBIG:\n                                        return Fail(ThrowRangeError, \"The bound string, buffer, or bigint is too big\");\n                                case SQLITE_RANGE:\n                                        return Fail(ThrowRangeError, \"Too many parameter values were provided\");\n                                case SQLITE_NOMEM:\n                                        return Fail(ThrowError, \"Out of memory\");\n                                default:\n                                        return Fail(ThrowError, \"An unexpected error occured while trying to bind parameters\");\n                        }\n                        assert(false);\n                }\n}\n#line 78 \"./src/util/binder.lzz\"\nint Binder::BindArray (v8::Isolate * isolate, v8::Local <v8::Array> arr)\n#line 78 \"./src/util/binder.lzz\"\n                                                                      {\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                uint32_t length = arr->Length();\n                if (length > INT_MAX) {\n                        Fail(ThrowRangeError, \"Too many parameter values were provided\");\n                        return 0;\n                }\n                int len = static_cast<int>(length);\n                for (int i=0; i<len; ++i) {\n                        v8::MaybeLocal<v8::Value> maybeValue = arr->Get(ctx, i);\n                        if (maybeValue.IsEmpty()) {\n                                Fail(NULL, NULL);\n                                return i;\n                        }\n                        BindValue(isolate, maybeValue.ToLocalChecked(), NextAnonIndex());\n                        if (!success) {\n                                return i;\n                        }\n                }\n                return len;\n}\n#line 104 \"./src/util/binder.lzz\"\nint Binder::BindObject (v8::Isolate * isolate, v8::Local <v8::Object> obj, Statement * stmt)\n#line 104 \"./src/util/binder.lzz\"\n                                                                                         {\n                v8 :: Local < v8 :: Context > ctx = isolate -> GetCurrentContext ( ) ;\n                BindMap* bind_map = stmt->GetBindMap(isolate);\n                BindMap::Pair* pairs = bind_map->GetPairs();\n                int len = bind_map->GetSize();\n\n                for (int i=0; i<len; ++i) {\n                        v8::Local<v8::String> key = pairs[i].GetName(isolate);\n\n\n                        v8::Maybe<bool> has_property = obj->HasOwnProperty(ctx, key);\n                        if (has_property.IsNothing()) {\n                                Fail(NULL, NULL);\n                                return i;\n                        }\n                        if (!has_property.FromJust()) {\n                                v8::String::Utf8Value param_name(isolate, key);\n                                Fail(ThrowRangeError, CONCAT(\"Missing named parameter \\\"\", *param_name, \"\\\"\").c_str());\n                                return i;\n                        }\n\n\n                        v8::MaybeLocal<v8::Value> maybeValue = obj->Get(ctx, key);\n                        if (maybeValue.IsEmpty()) {\n                                Fail(NULL, NULL);\n                                return i;\n                        }\n\n                        BindValue(isolate, maybeValue.ToLocalChecked(), pairs[i].GetIndex());\n                        if (!success) {\n                                return i;\n                        }\n                }\n\n                return len;\n}\n#line 148 \"./src/util/binder.lzz\"\nBinder::Result Binder::BindArgs (v8::FunctionCallbackInfo <v8 :: Value> const & info, int argc, Statement * stmt)\n#line 148 \"./src/util/binder.lzz\"\n                                                                        {\n                v8 :: Isolate * isolate = info . GetIsolate ( ) ;\n                int count = 0;\n                bool bound_object = false;\n\n                for (int i=0; i<argc; ++i) {\n                        v8::Local<v8::Value> arg = info[i];\n\n                        if (arg->IsArray()) {\n                                count += BindArray(isolate, v8::Local<v8::Array>::Cast(arg));\n                                if (!success) break;\n                                continue;\n                        }\n\n                        if (arg->IsObject() && !node::Buffer::HasInstance(arg)) {\n                                v8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(arg);\n                                if (IsPlainObject(isolate, obj)) {\n                                        if (bound_object) {\n                                                Fail(ThrowTypeError, \"You cannot specify named parameters in two different objects\");\n                                                break;\n                                        }\n                                        bound_object = true;\n\n                                        count += BindObject(isolate, obj, stmt);\n                                        if (!success) break;\n                                        continue;\n                                }\n                        }\n\n                        BindValue(isolate, arg, NextAnonIndex());\n                        if (!success) break;\n                        count += 1;\n                }\n\n                return { count, bound_object };\n}\n#line 32 \"./src/better_sqlite3.lzz\"\nAddon::Addon (v8::Isolate * isolate)\n#line 32 \"./src/better_sqlite3.lzz\"\n  : privileged_info (NULL), bit_field (0), cs (isolate)\n#line 32 \"./src/better_sqlite3.lzz\"\n                                                                                       {}\n#line 43 \"./src/better_sqlite3.lzz\"\nvoid Addon::JS_setErrorConstructor (v8::FunctionCallbackInfo <v8 :: Value> const & info)\n#line 43 \"./src/better_sqlite3.lzz\"\n                                            {\n                if ( info . Length ( ) <= ( 0 ) || ! info [ 0 ] -> IsFunction ( ) ) return ThrowTypeError ( \"Expected \" \"first\" \" argument to be \" \"a function\" ) ; v8 :: Local < v8 :: Function > SqliteError = v8 :: Local < v8 :: Function > :: Cast ( info [ 0 ] ) ;\n                static_cast < Addon * > ( v8 :: Local < v8 :: External > :: Cast ( info . Data ( ) ) -> Value ( ) ) ->SqliteError.Reset( info . GetIsolate ( ) , SqliteError);\n}\n#line 48 \"./src/better_sqlite3.lzz\"\nvoid Addon::Cleanup (void * ptr)\n#line 48 \"./src/better_sqlite3.lzz\"\n                                       {\n                Addon* addon = static_cast<Addon*>(ptr);\n                for (Database* db : addon->dbs) db->CloseHandles();\n                addon->dbs.clear();\n                delete addon;\n}\n#undef LZZ_INLINE\n"