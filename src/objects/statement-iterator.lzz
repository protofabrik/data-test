"class StatementIterator : public node::ObjectWrap {\npublic:\n\n\tINIT(Init) {\n\t\tv8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"StatementIterator\");\n\t\tSetPrototypeMethod(isolate, data, t, \"next\", JS_next);\n\t\tSetPrototypeMethod(isolate, data, t, \"return\", JS_return);\n\t\tSetPrototypeSymbolMethod(isolate, data, t, v8::Symbol::GetIterator(isolate), JS_symbolIterator);\n\t\treturn t->GetFunction(OnlyContext).ToLocalChecked();\n\t}\n\n\t// The ~Statement destructor currently covers any state this object creates.\n\t// Additionally, we actually DON'T want to set stmt->locked or db_state\n\t// ->iterators in this destructor, to ensure deterministic database access.\n\t~StatementIterator() {}\n\nprivate:\n\n\texplicit StatementIterator(Statement* _stmt, bool _bound) : node::ObjectWrap(),\n\t\tstmt(_stmt),\n\t\thandle(_stmt->handle),\n\t\tdb_state(_stmt->db->GetState()),\n\t\tbound(_bound),\n\t\tsafe_ints(_stmt->safe_ints),\n\t\tmode(_stmt->mode),\n\t\talive(true),\n\t\tlogged(!db_state->has_logger) {\n\t\tassert(stmt != NULL);\n\t\tassert(handle != NULL);\n\t\tassert(stmt->bound == bound);\n\t\tassert(stmt->alive == true);\n\t\tassert(stmt->locked == false);\n\t\tassert(db_state->iterators < USHRT_MAX);\n\t\tstmt->locked = true;\n\t\tdb_state->iterators += 1;\n\t}\n\n\tNODE_METHOD(JS_new) {\n\t\tUseAddon;\n\t\tif (!addon->privileged_info) return ThrowTypeError(\"Disabled constructor\");\n\t\tassert(info.IsConstructCall());\n\n\t\tStatementIterator* iter;\n\t\t{\n\t\t\tNODE_ARGUMENTS info = *addon->privileged_info;\n\t\t\tSTATEMENT_START_LOGIC(REQUIRE_STATEMENT_RETURNS_DATA, DOES_ADD_ITERATOR);\n\t\t\titer = new StatementIterator(stmt, bound);\n\t\t}\n\t\tUseIsolate;\n\t\tUseContext;\n\t\titer->Wrap(info.This());\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.statement, addon->privileged_info->This());\n\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_next) {\n\t\tStatementIterator* iter = Unwrap<StatementIterator>(info.This());\n\t\tREQUIRE_DATABASE_NOT_BUSY(iter->db_state);\n\t\tif (iter->alive) iter->Next(info);\n\t\telse info.GetReturnValue().Set(DoneRecord(OnlyIsolate, iter->db_state->addon));\n\t}\n\n\tNODE_METHOD(JS_return) {\n\t\tStatementIterator* iter = Unwrap<StatementIterator>(info.This());\n\t\tREQUIRE_DATABASE_NOT_BUSY(iter->db_state);\n\t\tif (iter->alive) iter->Return(info);\n\t\telse info.GetReturnValue().Set(DoneRecord(OnlyIsolate, iter->db_state->addon));\n\t}\n\n\tNODE_METHOD(JS_symbolIterator) {\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tvoid Next(NODE_ARGUMENTS info) {\n\t\tassert(alive == true);\n\t\tdb_state->busy = true;\n\t\tif (!logged) {\n\t\t\tlogged = true;\n\t\t\tif (stmt->db->Log(OnlyIsolate, handle)) {\n\t\t\t\tdb_state->busy = false;\n\t\t\t\tThrow();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint status = sqlite3_step(handle);\n\t\tdb_state->busy = false;\n\t\tif (status == SQLITE_ROW) {\n\t\t\tUseIsolate;\n\t\t\tUseContext;\n\t\t\tinfo.GetReturnValue().Set(\n\t\t\t\tNewRecord(isolate, ctx, Data::GetRowJS(isolate, ctx, handle, safe_ints, mode), db_state->addon, false)\n\t\t\t);\n\t\t} else {\n\t\t\tif (status == SQLITE_DONE) Return(info);\n\t\t\telse Throw();\n\t\t}\n\t}\n\n\tvoid Return(NODE_ARGUMENTS info) {\n\t\tCleanup();\n\t\tSTATEMENT_RETURN_LOGIC(DoneRecord(OnlyIsolate, db_state->addon));\n\t}\n\n\tvoid Throw() {\n\t\tCleanup();\n\t\tDatabase* db = stmt->db;\n\t\tSTATEMENT_THROW_LOGIC();\n\t}\n\n\tvoid Cleanup() {\n\t\tassert(alive == true);\n\t\talive = false;\n\t\tstmt->locked = false;\n\t\tdb_state->iterators -= 1;\n\t\tsqlite3_reset(handle);\n\t}\n\n\tstatic inline v8::Local<v8::Object> NewRecord(v8::Isolate* isolate, v8::Local<v8::Context> ctx, v8::Local<v8::Value> value, Addon* addon, bool done) {\n\t\tv8::Local<v8::Object> record = v8::Object::New(isolate);\n\t\trecord->Set(ctx, CS::Get(isolate, addon->cs.value), value).FromJust();\n\t\trecord->Set(ctx, CS::Get(isolate, addon->cs.done), v8::Boolean::New(isolate, done)).FromJust();\n\t\treturn record;\n\t}\n\n\tstatic inline v8::Local<v8::Object> DoneRecord(v8::Isolate* isolate, Addon* addon) {\n\t\treturn NewRecord(isolate, OnlyContext, v8::Undefined(isolate), addon, true);\n\t}\n\n\tStatement* const stmt;\n\tsqlite3_stmt* const handle;\n\tDatabase::State* const db_state;\n\tconst bool bound;\n\tconst bool safe_ints;\n\tconst char mode;\n\tbool alive;\n\tbool logged;\n};\n"