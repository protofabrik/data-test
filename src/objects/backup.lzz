"class Backup : public node::ObjectWrap {\npublic:\n\n\tINIT(Init) {\n\t\tv8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"Backup\");\n\t\tSetPrototypeMethod(isolate, data, t, \"transfer\", JS_transfer);\n\t\tSetPrototypeMethod(isolate, data, t, \"close\", JS_close);\n\t\treturn t->GetFunction(OnlyContext).ToLocalChecked();\n\t}\n\n\t// Used to support ordered containers.\n\tstatic inline bool Compare(Backup const * const a, Backup const * const b) {\n\t\treturn a->id < b->id;\n\t}\n\n\t// Whenever this is used, db->RemoveBackup must be invoked beforehand.\n\tvoid CloseHandles() {\n\t\tif (alive) {\n\t\t\talive = false;\n\t\t\tstd::string filename(sqlite3_db_filename(dest_handle, \"main\"));\n\t\t\tsqlite3_backup_finish(backup_handle);\n\t\t\tint status = sqlite3_close(dest_handle);\n\t\t\tassert(status == SQLITE_OK); ((void)status);\n\t\t\tif (unlink) remove(filename.c_str());\n\t\t}\n\t}\n\n\n\t~Backup() {\n\t\tif (alive) db->RemoveBackup(this);\n\t\tCloseHandles();\n\t}\n\nprivate:\n\n\texplicit Backup(Database* _db, sqlite3* _dest_handle, sqlite3_backup* _backup_handle, sqlite3_uint64 _id, bool _unlink) : node::ObjectWrap(),\n\t\tdb(_db),\n\t\tdest_handle(_dest_handle),\n\t\tbackup_handle(_backup_handle),\n\t\tid(_id),\n\t\talive(true),\n\t\tunlink(_unlink) {\n\t\tassert(db != NULL);\n\t\tassert(dest_handle != NULL);\n\t\tassert(backup_handle != NULL);\n\t\tdb->AddBackup(this);\n\t}\n\n\tNODE_METHOD(JS_new) {\n\t\tUseAddon;\n\t\tif (!addon->privileged_info) return ThrowTypeError(\"Disabled constructor\");\n\t\tassert(info.IsConstructCall());\n\t\tv8::Local<v8::Object> database = addon->privileged_info->This();\n\t\tDatabase* db = Unwrap<Database>(database);\n\t\tREQUIRE_DATABASE_OPEN(db->GetState());\n\t\tREQUIRE_DATABASE_NOT_BUSY(db->GetState());\n\n\t\tv8::Local<v8::String> attachedName = v8::Local<v8::String>::Cast((*addon->privileged_info)[0]);\n\t\tv8::Local<v8::String> destFile = v8::Local<v8::String>::Cast((*addon->privileged_info)[1]);\n\t\tbool unlink = v8::Local<v8::Boolean>::Cast((*addon->privileged_info)[2])->Value();\n\n\t\tUseIsolate;\n\t\tsqlite3* dest_handle;\n\t\tv8::String::Utf8Value dest_file(isolate, destFile);\n\t\tv8::String::Utf8Value attached_name(isolate, attachedName);\n\t\tint mask = (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);\n\n\t\tif (sqlite3_open_v2(*dest_file, &dest_handle, mask, NULL) != SQLITE_OK) {\n\t\t\tDatabase::ThrowSqliteError(addon, dest_handle);\n\t\t\tint status = sqlite3_close(dest_handle);\n\t\t\tassert(status == SQLITE_OK); ((void)status);\n\t\t\treturn;\n\t\t}\n\n\t\tsqlite3_extended_result_codes(dest_handle, 1);\n\t\tsqlite3_limit(dest_handle, SQLITE_LIMIT_LENGTH, INT_MAX);\n\t\tsqlite3_backup* backup_handle = sqlite3_backup_init(dest_handle, \"main\", db->GetHandle(), *attached_name);\n\t\tif (backup_handle == NULL) {\n\t\t\tDatabase::ThrowSqliteError(addon, dest_handle);\n\t\t\tint status = sqlite3_close(dest_handle);\n\t\t\tassert(status == SQLITE_OK); ((void)status);\n\t\t\treturn;\n\t\t}\n\n\t\tBackup* backup = new Backup(db, dest_handle, backup_handle, addon->NextId(), unlink);\n\t\tbackup->Wrap(info.This());\n\t\tSetFrozen(isolate, OnlyContext, info.This(), addon->cs.database, database);\n\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_transfer) {\n\t\tBackup* backup = Unwrap<Backup>(info.This());\n\t\tREQUIRE_ARGUMENT_INT32(first, int pages);\n\t\tREQUIRE_DATABASE_OPEN(backup->db->GetState());\n\t\tassert(backup->db->GetState()->busy == false);\n\t\tassert(backup->alive == true);\n\n\t\tsqlite3_backup* backup_handle = backup->backup_handle;\n\t\tint status = sqlite3_backup_step(backup_handle, pages) & 0xff;\n\n\t\tAddon* addon = backup->db->GetAddon();\n\t\tif (status == SQLITE_OK || status == SQLITE_DONE || status == SQLITE_BUSY) {\n\t\t\tint total_pages = sqlite3_backup_pagecount(backup_handle);\n\t\t\tint remaining_pages = sqlite3_backup_remaining(backup_handle);\n\t\t\tUseIsolate;\n\t\t\tUseContext;\n\t\t\tv8::Local<v8::Object> result = v8::Object::New(isolate);\n\t\t\tresult->Set(ctx, CS::Get(isolate, addon->cs.totalPages), v8::Int32::New(isolate, total_pages)).FromJust();\n\t\t\tresult->Set(ctx, CS::Get(isolate, addon->cs.remainingPages), v8::Int32::New(isolate, remaining_pages)).FromJust();\n\t\t\tinfo.GetReturnValue().Set(result);\n\t\t\tif (status == SQLITE_DONE) backup->unlink = false;\n\t\t} else {\n\t\t\tDatabase::ThrowSqliteError(addon, sqlite3_errstr(status), status);\n\t\t}\n\t}\n\n\tNODE_METHOD(JS_close) {\n\t\tBackup* backup = Unwrap<Backup>(info.This());\n\t\tassert(backup->db->GetState()->busy == false);\n\t\tif (backup->alive) backup->db->RemoveBackup(backup);\n\t\tbackup->CloseHandles();\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tDatabase* const db;\n\tsqlite3* const dest_handle;\n\tsqlite3_backup* const backup_handle;\n\tconst sqlite3_uint64 id;\n\tbool alive;\n\tbool unlink;\n};\n"