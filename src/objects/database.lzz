"class Database : public node::ObjectWrap {\npublic:\n\n\tINIT(Init) {\n\t\tv8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"Database\");\n\t\tSetPrototypeMethod(isolate, data, t, \"prepare\", JS_prepare);\n\t\tSetPrototypeMethod(isolate, data, t, \"exec\", JS_exec);\n\t\tSetPrototypeMethod(isolate, data, t, \"pragma\", JS_pragma);\n\t\tSetPrototypeMethod(isolate, data, t, \"backup\", JS_backup);\n\t\tSetPrototypeMethod(isolate, data, t, \"function\", JS_function);\n\t\tSetPrototypeMethod(isolate, data, t, \"aggregate\", JS_aggregate);\n\t\tSetPrototypeMethod(isolate, data, t, \"loadExtension\", JS_loadExtension);\n\t\tSetPrototypeMethod(isolate, data, t, \"close\", JS_close);\n\t\tSetPrototypeMethod(isolate, data, t, \"defaultSafeIntegers\", JS_defaultSafeIntegers);\n\t\tSetPrototypeMethod(isolate, data, t, \"unsafeMode\", JS_unsafeMode);\n\t\tSetPrototypeGetter(isolate, data, t, \"open\", JS_open);\n\t\tSetPrototypeGetter(isolate, data, t, \"inTransaction\", JS_inTransaction);\n\t\treturn t->GetFunction(OnlyContext).ToLocalChecked();\n\t}\n\n\t// Used to support ordered containers.\n\tclass CompareDatabase { public:\n\t\tbool operator() (Database const * const a, Database const * const b) const {\n\t\t\treturn a < b;\n\t\t}\n\t};\n\tclass CompareStatement { public:\n\t\tbool operator() (Statement const * const a, Statement const * const b) const {\n\t\t\treturn Statement::Compare(a, b);\n\t\t}\n\t};\n\tclass CompareBackup { public:\n\t\tbool operator() (Backup const * const a, Backup const * const b) const {\n\t\t\treturn Backup::Compare(a, b);\n\t\t}\n\t};\n\n\t// Proper error handling logic for when an sqlite3 operation fails.\n\tvoid ThrowDatabaseError() {\n\t\tif (was_js_error) was_js_error = false;\n\t\telse ThrowSqliteError(addon, db_handle);\n\t}\n\tstatic void ThrowSqliteError(Addon* addon, sqlite3* db_handle) {\n\t\tassert(db_handle != NULL);\n\t\tThrowSqliteError(addon, sqlite3_errmsg(db_handle), sqlite3_extended_errcode(db_handle));\n\t}\n\tstatic void ThrowSqliteError(Addon* addon, const char* message, int code) {\n\t\tassert(message != NULL);\n\t\tassert((code & 0xff) != SQLITE_OK);\n\t\tassert((code & 0xff) != SQLITE_ROW);\n\t\tassert((code & 0xff) != SQLITE_DONE);\n\t\tEasyIsolate;\n\t\tv8::Local<v8::Value> args[2] = {\n\t\t\tStringFromUtf8(isolate, message, -1),\n\t\t\taddon->cs.Code(isolate, code)\n\t\t};\n\t\tisolate->ThrowException(v8::Local<v8::Function>::New(isolate, addon->SqliteError)\n\t\t\t->NewInstance(OnlyContext, 2, args)\n\t\t\t.ToLocalChecked());\n\t}\n\n\t// Allows Statements to log their executed SQL.\n\tbool Log(v8::Isolate* isolate, sqlite3_stmt* handle) {\n\t\tassert(was_js_error == false);\n\t\tif (!has_logger) return false;\n\t\tchar* expanded = sqlite3_expanded_sql(handle);\n\t\tv8::Local<v8::Value> arg = StringFromUtf8(isolate, expanded ? expanded : sqlite3_sql(handle), -1);\n\t\twas_js_error = v8::Local<v8::Function>::Cast(v8::Local<v8::Value>::New(isolate, logger))\n\t\t\t->Call(OnlyContext, v8::Undefined(isolate), 1, &arg)\n\t\t\t.IsEmpty();\n\t\tif (expanded) sqlite3_free(expanded);\n\t\treturn was_js_error;\n\t}\n\n\t// Allow Statements to manage themselves when created and garbage collected.\n\tinline void AddStatement(Statement* stmt) { stmts.insert(stmts.end(), stmt); }\n\tinline void RemoveStatement(Statement* stmt) { stmts.erase(stmt); }\n\n\t// Allow Backups to manage themselves when created and garbage collected.\n\tinline void AddBackup(Backup* backup) { backups.insert(backups.end(), backup); }\n\tinline void RemoveBackup(Backup* backup) { backups.erase(backup); }\n\n\t// A view for Statements to see and modify Database state.\n\t// The order of these fields must exactly match their actual order.\n\tstruct State {\n\t\tconst bool open;\n\t\tbool busy;\n\t\tconst bool safe_ints;\n\t\tconst bool unsafe_mode;\n\t\tbool was_js_error;\n\t\tconst bool has_logger;\n\t\tunsigned short iterators;\n\t\tAddon* const addon;\n\t};\n\tinline State* GetState() {\n\t\treturn reinterpret_cast<State*>(&open);\n\t}\n\tinline sqlite3* GetHandle() {\n\t\treturn db_handle;\n\t}\n\tinline Addon* GetAddon() {\n\t\treturn addon;\n\t}\n\n\t// Whenever this is used, addon->dbs.erase() must be invoked beforehand.\n\tvoid CloseHandles() {\n\t\tif (open) {\n\t\t\topen = false;\n\t\t\tfor (Statement* stmt : stmts) stmt->CloseHandles();\n\t\t\tfor (Backup* backup : backups) backup->CloseHandles();\n\t\t\tstmts.clear();\n\t\t\tbackups.clear();\n\t\t\tint status = sqlite3_close(db_handle);\n\t\t\tassert(status == SQLITE_OK); ((void)status);\n\t\t}\n\t}\n\n\t~Database() {\n\t\tif (open) addon->dbs.erase(this);\n\t\tCloseHandles();\n\t}\n\nprivate:\n\n\texplicit Database(sqlite3* _db_handle, v8::Isolate* isolate, Addon* _addon, v8::Local<v8::Value> _logger) : node::ObjectWrap(),\n\t\tdb_handle(_db_handle),\n\t\topen(true),\n\t\tbusy(false),\n\t\tsafe_ints(false),\n\t\tunsafe_mode(false),\n\t\twas_js_error(false),\n\t\thas_logger(_logger->IsFunction()),\n\t\titerators(0),\n\t\taddon(_addon),\n\t\tlogger(isolate, _logger),\n\t\tstmts(),\n\t\tbackups() {\n\t\tassert(_db_handle != NULL);\n\t\taddon->dbs.insert(this);\n\t}\n\n\tNODE_METHOD(JS_new) {\n\t\tassert(info.IsConstructCall());\n\t\tREQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> filename);\n\t\tREQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> filenameGiven);\n\t\tREQUIRE_ARGUMENT_BOOLEAN(third, bool in_memory);\n\t\tREQUIRE_ARGUMENT_BOOLEAN(fourth, bool readonly);\n\t\tREQUIRE_ARGUMENT_BOOLEAN(fifth, bool must_exist);\n\t\tREQUIRE_ARGUMENT_INT32(sixth, int timeout);\n\t\tREQUIRE_ARGUMENT_ANY(seventh, v8::Local<v8::Value> logger);\n\n\t\tUseAddon;\n\t\tUseIsolate;\n\t\tsqlite3* db_handle;\n\t\tv8::String::Utf8Value utf8(isolate, filename);\n\t\tint mask = readonly ? SQLITE_OPEN_READONLY\n\t\t\t: must_exist ? SQLITE_OPEN_READWRITE\n\t\t\t: (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);\n\n\t\tif (sqlite3_open_v2(*utf8, &db_handle, mask, NULL) != SQLITE_OK) {\n\t\t\tThrowSqliteError(addon, db_handle);\n\t\t\tint status = sqlite3_close(db_handle);\n\t\t\tassert(status == SQLITE_OK); ((void)status);\n\t\t\treturn;\n\t\t}\n\n\t\tassert(sqlite3_db_mutex(db_handle) == NULL);\n\t\tsqlite3_extended_result_codes(db_handle, 1);\n\t\tsqlite3_busy_timeout(db_handle, timeout);\n\t\tsqlite3_limit(db_handle, SQLITE_LIMIT_LENGTH, MAX_BUFFER_SIZE < MAX_STRING_SIZE ? MAX_BUFFER_SIZE : MAX_STRING_SIZE);\n\t\tsqlite3_limit(db_handle, SQLITE_LIMIT_SQL_LENGTH, MAX_STRING_SIZE);\n\t\tint status = sqlite3_db_config(db_handle, SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, 1, NULL);\n\t\tassert(status == SQLITE_OK);\n\t\tstatus = sqlite3_db_config(db_handle, SQLITE_DBCONFIG_DEFENSIVE, 1, NULL);\n\t\tassert(status == SQLITE_OK);\n\n\t\tUseContext;\n\t\tDatabase* db = new Database(db_handle, isolate, addon, logger);\n\t\tdb->Wrap(info.This());\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.memory, v8::Boolean::New(isolate, in_memory));\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.readonly, v8::Boolean::New(isolate, readonly));\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.name, filenameGiven);\n\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_prepare) {\n\t\tREQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> source);\n\t\t(void)source;\n\t\tUseAddon;\n\t\tUseIsolate;\n\t\tv8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, addon->Statement);\n\t\taddon->privileged_info = &info;\n\t\tv8::MaybeLocal<v8::Object> maybe_statement = c->NewInstance(OnlyContext, 0, NULL);\n\t\taddon->privileged_info = NULL;\n\t\tif (!maybe_statement.IsEmpty()) info.GetReturnValue().Set(maybe_statement.ToLocalChecked());\n\t}\n\n\tNODE_METHOD(JS_exec) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tREQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> source);\n\t\tREQUIRE_DATABASE_OPEN(db);\n\t\tREQUIRE_DATABASE_NOT_BUSY(db);\n\t\tREQUIRE_DATABASE_NO_ITERATORS_UNLESS_UNSAFE(db);\n\t\tdb->busy = true;\n\n\t\tUseIsolate;\n\t\tv8::String::Utf8Value utf8(isolate, source);\n\t\tconst char* sql = *utf8;\n\t\tconst char* tail;\n\n\t\tint status;\n\t\tconst bool has_logger = db->has_logger;\n\t\tsqlite3* const db_handle = db->db_handle;\n\t\tsqlite3_stmt* handle;\n\n\t\tfor (;;) {\n\t\t\twhile (IS_SKIPPED(*sql)) ++sql;\n\t\t\tstatus = sqlite3_prepare_v2(db_handle, sql, -1, &handle, &tail);\n\t\t\tsql = tail;\n\t\t\tif (!handle) break;\n\t\t\tif (has_logger && db->Log(isolate, handle)) {\n\t\t\t\tsqlite3_finalize(handle);\n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdo status = sqlite3_step(handle);\n\t\t\twhile (status == SQLITE_ROW);\n\t\t\tstatus = sqlite3_finalize(handle);\n\t\t\tif (status != SQLITE_OK) break;\n\t\t}\n\n\t\tdb->busy = false;\n\t\tif (status == SQLITE_OK) info.GetReturnValue().Set(info.This());\n\t\telse db->ThrowDatabaseError();\n\t}\n\n\tNODE_METHOD(JS_pragma) {\n\t\tREQUIRE_ARGUMENT_BOOLEAN(first, bool active);\n\t\tOnlyAddon->SetPragmaMode(active);\n\t}\n\n\tNODE_METHOD(JS_backup) {\n\t\tREQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> attachedName);\n\t\tREQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> destFile);\n\t\tREQUIRE_ARGUMENT_BOOLEAN(third, bool unlink);\n\t\t(void)attachedName;\n\t\t(void)destFile;\n\t\t(void)unlink;\n\t\tUseAddon;\n\t\tUseIsolate;\n\t\tv8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, addon->Backup);\n\t\taddon->privileged_info = &info;\n\t\tv8::MaybeLocal<v8::Object> maybe_backup = c->NewInstance(OnlyContext, 0, NULL);\n\t\taddon->privileged_info = NULL;\n\t\tif (!maybe_backup.IsEmpty()) info.GetReturnValue().Set(maybe_backup.ToLocalChecked());\n\t}\n\n\tNODE_METHOD(JS_function) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tREQUIRE_ARGUMENT_FUNCTION(first, v8::Local<v8::Function> fn);\n\t\tREQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> nameString);\n\t\tREQUIRE_ARGUMENT_INT32(third, int argc);\n\t\tREQUIRE_ARGUMENT_INT32(fourth, int safe_ints);\n\t\tREQUIRE_ARGUMENT_BOOLEAN(fifth, bool deterministic);\n\t\tREQUIRE_DATABASE_OPEN(db);\n\t\tREQUIRE_DATABASE_NOT_BUSY(db);\n\t\tREQUIRE_DATABASE_NO_ITERATORS(db);\n\n\t\tUseIsolate;\n\t\tv8::String::Utf8Value name(isolate, nameString);\n\t\tint mask = deterministic ? SQLITE_UTF8 | SQLITE_DETERMINISTIC : SQLITE_UTF8;\n\t\tsafe_ints = safe_ints < 2 ? safe_ints : static_cast<int>(db->safe_ints);\n\n\t\tif (sqlite3_create_function_v2(db->db_handle, *name, argc, mask, new CustomFunction(isolate, db, fn, *name, safe_ints), CustomFunction::xFunc, NULL, NULL, CustomFunction::xDestroy) != SQLITE_OK) {\n\t\t\treturn db->ThrowDatabaseError();\n\t\t}\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_aggregate) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tREQUIRE_ARGUMENT_ANY(first, v8::Local<v8::Value> start);\n\t\tREQUIRE_ARGUMENT_FUNCTION(second, v8::Local<v8::Function> step);\n\t\tREQUIRE_ARGUMENT_ANY(third, v8::Local<v8::Value> inverse);\n\t\tREQUIRE_ARGUMENT_ANY(fourth, v8::Local<v8::Value> result);\n\t\tREQUIRE_ARGUMENT_STRING(fifth, v8::Local<v8::String> nameString);\n\t\tREQUIRE_ARGUMENT_INT32(sixth, int argc);\n\t\tREQUIRE_ARGUMENT_INT32(seventh, int safe_ints);\n\t\tREQUIRE_ARGUMENT_BOOLEAN(eighth, bool deterministic);\n\t\tREQUIRE_DATABASE_OPEN(db);\n\t\tREQUIRE_DATABASE_NOT_BUSY(db);\n\t\tREQUIRE_DATABASE_NO_ITERATORS(db);\n\n\t\tUseIsolate;\n\t\tv8::String::Utf8Value name(isolate, nameString);\n\t\tauto xInverse = inverse->IsFunction() ? CustomAggregate::xInverse : NULL;\n\t\tauto xValue = xInverse ? CustomAggregate::xValue : NULL;\n\t\tint mask = deterministic ? SQLITE_UTF8 | SQLITE_DETERMINISTIC : SQLITE_UTF8;\n\t\tsafe_ints = safe_ints < 2 ? safe_ints : static_cast<int>(db->safe_ints);\n\n\t\tif (sqlite3_create_window_function(db->db_handle, *name, argc, mask, new CustomAggregate(isolate, db, start, step, inverse, result, *name, safe_ints), CustomAggregate::xStep, CustomAggregate::xFinal, xValue, xInverse, CustomAggregate::xDestroy) != SQLITE_OK) {\n\t\t\treturn db->ThrowDatabaseError();\n\t\t}\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_loadExtension) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tv8::Local<v8::String> entryPoint;\n\t\tREQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> filename);\n\t\tif (info.Length() > 1) { REQUIRE_ARGUMENT_STRING(second, entryPoint); }\n\t\tREQUIRE_DATABASE_OPEN(db);\n\t\tREQUIRE_DATABASE_NOT_BUSY(db);\n\t\tREQUIRE_DATABASE_NO_ITERATORS(db);\n\t\tUseIsolate;\n\t\tchar* error;\n\t\tint status = sqlite3_load_extension(\n\t\t\tdb->db_handle,\n\t\t\t*v8::String::Utf8Value(isolate, filename),\n\t\t\tentryPoint.IsEmpty() ? NULL : *v8::String::Utf8Value(isolate, entryPoint),\n\t\t\t&error\n\t\t);\n\t\tif (status == SQLITE_OK) info.GetReturnValue().Set(info.This());\n\t\telse ThrowSqliteError(db->addon, error, status);\n\t\tsqlite3_free(error);\n\t}\n\n\tNODE_METHOD(JS_close) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tif (db->open) {\n\t\t\tREQUIRE_DATABASE_NOT_BUSY(db);\n\t\t\tREQUIRE_DATABASE_NO_ITERATORS(db);\n\t\t\tdb->addon->dbs.erase(db);\n\t\t\tdb->CloseHandles();\n\t\t}\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_defaultSafeIntegers) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tif (info.Length() == 0) db->safe_ints = true;\n\t\telse { REQUIRE_ARGUMENT_BOOLEAN(first, db->safe_ints); }\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_unsafeMode) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tif (info.Length() == 0) db->unsafe_mode = true;\n\t\telse { REQUIRE_ARGUMENT_BOOLEAN(first, db->unsafe_mode); }\n\t\tsqlite3_db_config(db->db_handle, SQLITE_DBCONFIG_DEFENSIVE, static_cast<int>(!db->unsafe_mode), NULL);\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_GETTER(JS_open) {\n\t\tinfo.GetReturnValue().Set(Unwrap<Database>(info.This())->open);\n\t}\n\n\tNODE_GETTER(JS_inTransaction) {\n\t\tDatabase* db = Unwrap<Database>(info.This());\n\t\tinfo.GetReturnValue().Set(db->open && !static_cast<bool>(sqlite3_get_autocommit(db->db_handle)));\n\t}\n\n\tstatic const int MAX_BUFFER_SIZE = node::Buffer::kMaxLength > INT_MAX ? INT_MAX : static_cast<int>(node::Buffer::kMaxLength);\n\tstatic const int MAX_STRING_SIZE = v8::String::kMaxLength > INT_MAX ? INT_MAX : static_cast<int>(v8::String::kMaxLength);\n\n\tsqlite3* const db_handle;\n\tbool open;\n\tbool busy;\n\tbool safe_ints;\n\tbool unsafe_mode;\n\tbool was_js_error;\n\tconst bool has_logger;\n\tunsigned short iterators;\n\tAddon* const addon;\n\tconst CopyablePersistent<v8::Value> logger;\n\tstd::set<Statement*, CompareStatement> stmts;\n\tstd::set<Backup*, CompareBackup> backups;\n};\n"