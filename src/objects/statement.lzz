"class Statement : public node::ObjectWrap {\nfriend class StatementIterator;\npublic:\n\n\tINIT(Init) {\n\t\tv8::Local<v8::FunctionTemplate> t = NewConstructorTemplate(isolate, data, JS_new, \"Statement\");\n\t\tSetPrototypeMethod(isolate, data, t, \"run\", JS_run);\n\t\tSetPrototypeMethod(isolate, data, t, \"get\", JS_get);\n\t\tSetPrototypeMethod(isolate, data, t, \"all\", JS_all);\n\t\tSetPrototypeMethod(isolate, data, t, \"iterate\", JS_iterate);\n\t\tSetPrototypeMethod(isolate, data, t, \"bind\", JS_bind);\n\t\tSetPrototypeMethod(isolate, data, t, \"pluck\", JS_pluck);\n\t\tSetPrototypeMethod(isolate, data, t, \"expand\", JS_expand);\n\t\tSetPrototypeMethod(isolate, data, t, \"raw\", JS_raw);\n\t\tSetPrototypeMethod(isolate, data, t, \"safeIntegers\", JS_safeIntegers);\n\t\tSetPrototypeMethod(isolate, data, t, \"columns\", JS_columns);\n\t\treturn t->GetFunction(OnlyContext).ToLocalChecked();\n\t}\n\n\t// Used to support ordered containers.\n\tstatic inline bool Compare(Statement const * const a, Statement const * const b) {\n\t\treturn a->extras->id < b->extras->id;\n\t}\n\n\t// Returns the Statement's bind map (creates it upon first execution).\n\tBindMap* GetBindMap(v8::Isolate* isolate) {\n\t\tif (has_bind_map) return &extras->bind_map;\n\t\tBindMap* bind_map = &extras->bind_map;\n\t\tint param_count = sqlite3_bind_parameter_count(handle);\n\t\tfor (int i=1; i<=param_count; ++i) {\n\t\t\tconst char* name = sqlite3_bind_parameter_name(handle, i);\n\t\t\tif (name != NULL) bind_map->Add(isolate, name + 1, i);\n\t\t}\n\t\thas_bind_map = true;\n\t\treturn bind_map;\n\t}\n\n\t// Whenever this is used, db->RemoveStatement must be invoked beforehand.\n\tvoid CloseHandles() {\n\t\tif (alive) {\n\t\t\talive = false;\n\t\t\tsqlite3_finalize(handle);\n\t\t}\n\t}\n\n\t~Statement() {\n\t\tif (alive) db->RemoveStatement(this);\n\t\tCloseHandles();\n\t\tdelete extras;\n\t}\n\nprivate:\n\n\t// A class for holding values that are less often used.\n\tclass Extras { friend class Statement;\n\t\texplicit Extras(sqlite3_uint64 _id) : bind_map(0), id(_id) {}\n\t\tBindMap bind_map;\n\t\tconst sqlite3_uint64 id;\n\t};\n\n\texplicit Statement(Database* _db, sqlite3_stmt* _handle, sqlite3_uint64 _id, bool _returns_data) : node::ObjectWrap(),\n\t\tdb(_db),\n\t\thandle(_handle),\n\t\textras(new Extras(_id)),\n\t\talive(true),\n\t\tlocked(false),\n\t\tbound(false),\n\t\thas_bind_map(false),\n\t\tsafe_ints(_db->GetState()->safe_ints),\n\t\tmode(Data::FLAT),\n\t\treturns_data(_returns_data) {\n\t\tassert(db != NULL);\n\t\tassert(handle != NULL);\n\t\tassert(db->GetState()->open);\n\t\tassert(!db->GetState()->busy);\n\t\tdb->AddStatement(this);\n\t}\n\n\tNODE_METHOD(JS_new) {\n\t\tUseAddon;\n\t\tif (!addon->privileged_info) {\n\t\t\treturn ThrowTypeError(\"Statements can only be constructed by the db.prepare() method\");\n\t\t}\n\t\tassert(info.IsConstructCall());\n\t\tv8::Local<v8::Object> database = addon->privileged_info->This();\n\t\tDatabase* db = Unwrap<Database>(database);\n\t\tint flags = SQLITE_PREPARE_PERSISTENT;\n\t\tREQUIRE_DATABASE_OPEN(db->GetState());\n\t\tREQUIRE_DATABASE_NOT_BUSY(db->GetState());\n\t\tif (addon->PragmaMode()) {\n\t\t\tREQUIRE_DATABASE_NO_ITERATORS_UNLESS_UNSAFE(db->GetState());\n\t\t\tflags = 0;\n\t\t}\n\n\t\tUseIsolate;\n\t\tv8::Local<v8::String> source = v8::Local<v8::String>::Cast((*addon->privileged_info)[0]);\n\t\tv8::String::Utf8Value utf8(isolate, source);\n\t\tsqlite3_stmt* handle;\n\t\tconst char* tail;\n\n\t\tif (sqlite3_prepare_v3(db->GetHandle(), *utf8, utf8.length() + 1, flags, &handle, &tail) != SQLITE_OK) {\n\t\t\treturn db->ThrowDatabaseError();\n\t\t}\n\t\tif (handle == NULL) {\n\t\t\treturn ThrowRangeError(\"The supplied SQL string contains no statements\");\n\t\t}\n\t\tfor (char c; (c = *tail); ++tail) {\n\t\t\tif (IS_SKIPPED(c)) continue;\n\t\t\tif (c == '/' && tail[1] == '*') {\n\t\t\t\ttail += 2;\n\t\t\t\tfor (char c; (c = *tail); ++tail) {\n\t\t\t\t\tif (c == '*' && tail[1] == '/') {\n\t\t\t\t\t\ttail += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c == '-' && tail[1] == '-') {\n\t\t\t\ttail += 2;\n\t\t\t\tfor (char c; (c = *tail); ++tail) {\n\t\t\t\t\tif (c == '\\n') break;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlite3_finalize(handle);\n\t\t\t\treturn ThrowRangeError(\"The supplied SQL string contains more than one statement\");\n\t\t\t}\n\t\t}\n\n\t\tUseContext;\n\t\tbool returns_data = (sqlite3_stmt_readonly(handle) && sqlite3_column_count(handle) >= 1) || addon->PragmaMode();\n\t\tStatement* stmt = new Statement(db, handle, addon->NextId(), returns_data);\n\t\tstmt->Wrap(info.This());\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.reader, v8::Boolean::New(isolate, returns_data));\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.source, source);\n\t\tSetFrozen(isolate, ctx, info.This(), addon->cs.database, database);\n\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_run) {\n\t\tSTATEMENT_START(REQUIRE_STATEMENT_DOESNT_RETURN_DATA, DOES_MUTATE);\n\t\tsqlite3* db_handle = db->GetHandle();\n\t\tint total_changes_before = sqlite3_total_changes(db_handle);\n\n\t\tsqlite3_step(handle);\n\t\tif (sqlite3_reset(handle) == SQLITE_OK) {\n\t\t\tint changes = sqlite3_total_changes(db_handle) == total_changes_before ? 0 : sqlite3_changes(db_handle);\n\t\t\tsqlite3_int64 id = sqlite3_last_insert_rowid(db_handle);\n\t\t\tAddon* addon = db->GetAddon();\n\t\t\tUseContext;\n\t\t\tv8::Local<v8::Object> result = v8::Object::New(isolate);\n\t\t\tresult->Set(ctx, CS::Get(isolate, addon->cs.changes), v8::Int32::New(isolate, changes)).FromJust();\n\t\t\tresult->Set(ctx, CS::Get(isolate, addon->cs.lastInsertRowid),\n\t\t\t\tstmt->safe_ints\n\t\t\t\t\t? v8::Local<v8::Value>::Cast(v8::BigInt::New(isolate, id))\n\t\t\t\t\t: v8::Local<v8::Value>::Cast(v8::Number::New(isolate, (double)id))\n\t\t\t).FromJust();\n\t\t\tSTATEMENT_RETURN(result);\n\t\t}\n\t\tSTATEMENT_THROW();\n\t}\n\n\tNODE_METHOD(JS_get) {\n\t\tSTATEMENT_START(REQUIRE_STATEMENT_RETURNS_DATA, DOES_NOT_MUTATE);\n\t\tint status = sqlite3_step(handle);\n\t\tif (status == SQLITE_ROW) {\n\t\t\tv8::Local<v8::Value> result = Data::GetRowJS(isolate, OnlyContext, handle, stmt->safe_ints, stmt->mode);\n\t\t\tsqlite3_reset(handle);\n\t\t\tSTATEMENT_RETURN(result);\n\t\t} else if (status == SQLITE_DONE) {\n\t\t\tsqlite3_reset(handle);\n\t\t\tSTATEMENT_RETURN(v8::Undefined(isolate));\n\t\t}\n\t\tsqlite3_reset(handle);\n\t\tSTATEMENT_THROW();\n\t}\n\n\tNODE_METHOD(JS_all) {\n\t\tSTATEMENT_START(REQUIRE_STATEMENT_RETURNS_DATA, DOES_NOT_MUTATE);\n\t\tUseContext;\n\t\tv8::Local<v8::Array> result = v8::Array::New(isolate, 0);\n\t\tuint32_t row_count = 0;\n\t\tconst bool safe_ints = stmt->safe_ints;\n\t\tconst char mode = stmt->mode;\n\t\tbool js_error = false;\n\n\t\twhile (sqlite3_step(handle) == SQLITE_ROW) {\n\t\t\tif (row_count == 0xffffffff) { ThrowRangeError(\"Array overflow (too many rows returned)\"); js_error = true; break; }\n\t\t\tresult->Set(ctx, row_count++, Data::GetRowJS(isolate, ctx, handle, safe_ints, mode)).FromJust();\n\t\t}\n\n\t\tif (sqlite3_reset(handle) == SQLITE_OK && !js_error) {\n\t\t\tSTATEMENT_RETURN(result);\n\t\t}\n\t\tif (js_error) db->GetState()->was_js_error = true;\n\t\tSTATEMENT_THROW();\n\t}\n\n\tNODE_METHOD(JS_iterate) {\n\t\tUseAddon;\n\t\tUseIsolate;\n\t\tv8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, addon->StatementIterator);\n\t\taddon->privileged_info = &info;\n\t\tv8::MaybeLocal<v8::Object> maybe_iter = c->NewInstance(OnlyContext, 0, NULL);\n\t\taddon->privileged_info = NULL;\n\t\tif (!maybe_iter.IsEmpty()) info.GetReturnValue().Set(maybe_iter.ToLocalChecked());\n\t}\n\n\tNODE_METHOD(JS_bind) {\n\t\tStatement* stmt = Unwrap<Statement>(info.This());\n\t\tif (stmt->bound) return ThrowTypeError(\"The bind() method can only be invoked once per statement object\");\n\t\tREQUIRE_DATABASE_OPEN(stmt->db->GetState());\n\t\tREQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());\n\t\tREQUIRE_STATEMENT_NOT_LOCKED(stmt);\n\t\tSTATEMENT_BIND(stmt->handle);\n\t\tstmt->bound = true;\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_pluck) {\n\t\tStatement* stmt = Unwrap<Statement>(info.This());\n\t\tif (!stmt->returns_data) return ThrowTypeError(\"The pluck() method is only for statements that return data\");\n\t\tREQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());\n\t\tREQUIRE_STATEMENT_NOT_LOCKED(stmt);\n\t\tbool use = true;\n\t\tif (info.Length() != 0) { REQUIRE_ARGUMENT_BOOLEAN(first, use); }\n\t\tstmt->mode = use ? Data::PLUCK : stmt->mode == Data::PLUCK ? Data::FLAT : stmt->mode;\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_expand) {\n\t\tStatement* stmt = Unwrap<Statement>(info.This());\n\t\tif (!stmt->returns_data) return ThrowTypeError(\"The expand() method is only for statements that return data\");\n\t\tREQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());\n\t\tREQUIRE_STATEMENT_NOT_LOCKED(stmt);\n\t\tbool use = true;\n\t\tif (info.Length() != 0) { REQUIRE_ARGUMENT_BOOLEAN(first, use); }\n\t\tstmt->mode = use ? Data::EXPAND : stmt->mode == Data::EXPAND ? Data::FLAT : stmt->mode;\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_raw) {\n\t\tStatement* stmt = Unwrap<Statement>(info.This());\n\t\tif (!stmt->returns_data) return ThrowTypeError(\"The raw() method is only for statements that return data\");\n\t\tREQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());\n\t\tREQUIRE_STATEMENT_NOT_LOCKED(stmt);\n\t\tbool use = true;\n\t\tif (info.Length() != 0) { REQUIRE_ARGUMENT_BOOLEAN(first, use); }\n\t\tstmt->mode = use ? Data::RAW : stmt->mode == Data::RAW ? Data::FLAT : stmt->mode;\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_safeIntegers) {\n\t\tStatement* stmt = Unwrap<Statement>(info.This());\n\t\tREQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());\n\t\tREQUIRE_STATEMENT_NOT_LOCKED(stmt);\n\t\tif (info.Length() == 0) stmt->safe_ints = true;\n\t\telse { REQUIRE_ARGUMENT_BOOLEAN(first, stmt->safe_ints); }\n\t\tinfo.GetReturnValue().Set(info.This());\n\t}\n\n\tNODE_METHOD(JS_columns) {\n\t\tStatement* stmt = Unwrap<Statement>(info.This());\n\t\tif (!stmt->returns_data) return ThrowTypeError(\"The columns() method is only for statements that return data\");\n\t\tREQUIRE_DATABASE_OPEN(stmt->db->GetState());\n\t\tREQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());\n\t\tAddon* addon = stmt->db->GetAddon();\n\t\tUseIsolate;\n\t\tUseContext;\n\n\t\tint column_count = sqlite3_column_count(stmt->handle);\n\t\tv8::Local<v8::Array> columns = v8::Array::New(isolate);\n\n\t\tv8::Local<v8::String> name = CS::Get(isolate, addon->cs.name);\n\t\tv8::Local<v8::String> columnName = CS::Get(isolate, addon->cs.column);\n\t\tv8::Local<v8::String> tableName = CS::Get(isolate, addon->cs.table);\n\t\tv8::Local<v8::String> databaseName = CS::Get(isolate, addon->cs.database);\n\t\tv8::Local<v8::String> typeName = CS::Get(isolate, addon->cs.type);\n\n\t\tfor (int i=0; i<column_count; ++i) {\n\t\t\tv8::Local<v8::Object> column = v8::Object::New(isolate);\n\n\t\t\tcolumn->Set(ctx, name,\n\t\t\t\tInternalizedFromUtf8OrNull(isolate, sqlite3_column_name(stmt->handle, i), -1)\n\t\t\t).FromJust();\n\t\t\tcolumn->Set(ctx, columnName,\n\t\t\t\tInternalizedFromUtf8OrNull(isolate, sqlite3_column_origin_name(stmt->handle, i), -1)\n\t\t\t).FromJust();\n\t\t\tcolumn->Set(ctx, tableName,\n\t\t\t\tInternalizedFromUtf8OrNull(isolate, sqlite3_column_table_name(stmt->handle, i), -1)\n\t\t\t).FromJust();\n\t\t\tcolumn->Set(ctx, databaseName,\n\t\t\t\tInternalizedFromUtf8OrNull(isolate, sqlite3_column_database_name(stmt->handle, i), -1)\n\t\t\t).FromJust();\n\t\t\tcolumn->Set(ctx, typeName,\n\t\t\t\tInternalizedFromUtf8OrNull(isolate, sqlite3_column_decltype(stmt->handle, i), -1)\n\t\t\t).FromJust();\n\n\t\t\tcolumns->Set(ctx, i, column).FromJust();\n\t\t}\n\n\t\tinfo.GetReturnValue().Set(columns);\n\t}\n\n\tDatabase* const db;\n\tsqlite3_stmt* const handle;\n\tExtras* const extras;\n\tbool alive;\n\tbool locked;\n\tbool bound;\n\tbool has_bind_map;\n\tbool safe_ints;\n\tchar mode;\n\tconst bool returns_data;\n};\n"