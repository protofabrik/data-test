"#define NODE_ARGUMENTS const v8::FunctionCallbackInfo<v8::Value>&\n#define NODE_ARGUMENTS_POINTER const v8::FunctionCallbackInfo<v8::Value>*\n#define NODE_METHOD(name) static void name(NODE_ARGUMENTS info)\n#define NODE_GETTER(name) static void name(v8::Local<v8::String> _, const v8::PropertyCallbackInfo<v8::Value>& info)\n#define INIT(name) static v8::Local<v8::Function> name(v8::Isolate* isolate, v8::Local<v8::External> data)\n\n#define EasyIsolate v8::Isolate* isolate = v8::Isolate::GetCurrent()\n#define OnlyIsolate info.GetIsolate()\n#define OnlyContext isolate->GetCurrentContext()\n#define OnlyAddon static_cast<Addon*>(v8::Local<v8::External>::Cast(info.Data())->Value())\n#define UseIsolate v8::Isolate* isolate = OnlyIsolate\n#define UseContext v8::Local<v8::Context> ctx = OnlyContext\n#define UseAddon Addon* addon = OnlyAddon\n#define Unwrap node::ObjectWrap::Unwrap\n\ninline v8::Local<v8::String> StringFromUtf8(v8::Isolate* isolate, const char* data, int length) {\n\treturn v8::String::NewFromUtf8(isolate, data, v8::NewStringType::kNormal, length).ToLocalChecked();\n}\ninline v8::Local<v8::String> InternalizedFromUtf8(v8::Isolate* isolate, const char* data, int length) {\n\treturn v8::String::NewFromUtf8(isolate, data, v8::NewStringType::kInternalized, length).ToLocalChecked();\n}\ninline v8::Local<v8::Value> InternalizedFromUtf8OrNull(v8::Isolate* isolate, const char* data, int length) {\n\tif (data == NULL) return v8::Null(isolate);\n\treturn InternalizedFromUtf8(isolate, data, length);\n}\ninline v8::Local<v8::String> InternalizedFromLatin1(v8::Isolate* isolate, const char* str) {\n\treturn v8::String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(str), v8::NewStringType::kInternalized).ToLocalChecked();\n}\n\n#hdr\ntemplate <class T> using CopyablePersistent = v8::Persistent<T, v8::CopyablePersistentTraits<T>>;\n#end\ninline void SetFrozen(v8::Isolate* isolate, v8::Local<v8::Context> ctx, v8::Local<v8::Object> obj, CopyablePersistent<v8::String>& key, v8::Local<v8::Value> value) {\n\tobj->DefineOwnProperty(ctx, CS::Get(isolate, key), value, static_cast<v8::PropertyAttribute>(v8::DontDelete | v8::ReadOnly)).FromJust();\n}\n\nvoid ThrowError(const char* message) { EasyIsolate; isolate->ThrowException(v8::Exception::Error(StringFromUtf8(isolate, message, -1))); }\nvoid ThrowTypeError(const char* message) { EasyIsolate; isolate->ThrowException(v8::Exception::TypeError(StringFromUtf8(isolate, message, -1))); }\nvoid ThrowRangeError(const char* message) { EasyIsolate; isolate->ThrowException(v8::Exception::RangeError(StringFromUtf8(isolate, message, -1))); }\n\n#define REQUIRE_ARGUMENT_ANY(at, var)                                          \\\n\tif (info.Length() <= (at()))                                               \\\n\t\treturn ThrowTypeError(\"Expected a \"#at\" argument\");                    \\\n\tvar = info[at()]\n\n#define _REQUIRE_ARGUMENT(at, var, Type, message, ...)                         \\\n\tif (info.Length() <= (at()) || !info[at()]->Is##Type())                    \\\n\t\treturn ThrowTypeError(\"Expected \"#at\" argument to be \"#message);       \\\n\tvar = v8::Local<v8::Type>::Cast(info[at()])__VA_ARGS__\n\n#define REQUIRE_ARGUMENT_INT32(at, var)                                        \\\n\t_REQUIRE_ARGUMENT(at, var, Int32, a 32-bit signed integer, ->Value())\n#define REQUIRE_ARGUMENT_BOOLEAN(at, var)                                      \\\n\t_REQUIRE_ARGUMENT(at, var, Boolean, a boolean, ->Value())\n#define REQUIRE_ARGUMENT_STRING(at, var)                                       \\\n\t_REQUIRE_ARGUMENT(at, var, String, a string)\n#define REQUIRE_ARGUMENT_OBJECT(at, var)                                       \\\n\t_REQUIRE_ARGUMENT(at, var, Object, an object)\n#define REQUIRE_ARGUMENT_FUNCTION(at, var)                                     \\\n\t_REQUIRE_ARGUMENT(at, var, Function, a function)\n\n#define REQUIRE_DATABASE_OPEN(db)                                              \\\n\tif (!db->open)                                                             \\\n\t\treturn ThrowTypeError(\"The database connection is not open\")\n#define REQUIRE_DATABASE_NOT_BUSY(db)                                          \\\n\tif (db->busy)                                                              \\\n\t\treturn ThrowTypeError(\"This database connection is busy executing a query\")\n#define REQUIRE_DATABASE_NO_ITERATORS(db)                                      \\\n\tif (db->iterators)                                                         \\\n\t\treturn ThrowTypeError(\"This database connection is busy executing a query\")\n#define REQUIRE_DATABASE_NO_ITERATORS_UNLESS_UNSAFE(db)                        \\\n\tif (!db->unsafe_mode) {                                                    \\\n\t\tREQUIRE_DATABASE_NO_ITERATORS(db);                                     \\\n\t} ((void)0)\n#define REQUIRE_STATEMENT_NOT_LOCKED(stmt)                                     \\\n\tif (stmt->locked)                                                          \\\n\t\treturn ThrowTypeError(\"This statement is busy executing a query\")\n\n#define first() 0\n#define second() 1\n#define third() 2\n#define fourth() 3\n#define fifth() 4\n#define sixth() 5\n#define seventh() 6\n#define eighth() 7\n#define ninth() 8\n#define tenth() 9\n\n// Returns a std:string of the concatenation of 3 well-formed C-strings.\nstd::string CONCAT(const char* a, const char* b, const char* c) {\n\tstd::string result(a);\n\tresult += b;\n\tresult += c;\n\treturn result;\n}\n\n// Returns a copy of a well-formed C-string.\nconst char* COPY(const char* source) {\n\tsize_t bytes = strlen(source) + 1;\n\tchar* dest = new char[bytes];\n\tmemcpy(dest, source, bytes);\n\treturn dest;\n}\n\n// Determines whether to skip the given character at the start of an SQL string.\ninline bool IS_SKIPPED(char c) {\n\treturn c == ' ' || c == ';' || (c >= '\\t' && c <= '\\r');\n}\n\n// Allocates an empty array, without calling constructors/initializers.\ntemplate<class T> inline T* ALLOC_ARRAY(size_t count) {\n\treturn static_cast<T*>(::operator new[](count * sizeof(T)));\n}\n\n// Deallocates an array, without calling destructors.\ntemplate<class T> inline void FREE_ARRAY(T* array_pointer) {\n\t::operator delete[](array_pointer);\n}\n\nv8::Local<v8::FunctionTemplate> NewConstructorTemplate(\n\tv8::Isolate* isolate,\n\tv8::Local<v8::External> data,\n\tv8::FunctionCallback func,\n\tconst char* name\n) {\n\tv8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, func, data);\n\tt->InstanceTemplate()->SetInternalFieldCount(1);\n\tt->SetClassName(InternalizedFromLatin1(isolate, name));\n\treturn t;\n}\nvoid SetPrototypeMethod(\n\tv8::Isolate* isolate,\n\tv8::Local<v8::External> data,\n\tv8::Local<v8::FunctionTemplate> recv,\n\tconst char* name,\n\tv8::FunctionCallback func\n) {\n\tv8::HandleScope scope(isolate);\n\trecv->PrototypeTemplate()->Set(\n\t\tInternalizedFromLatin1(isolate, name),\n\t\tv8::FunctionTemplate::New(isolate, func, data, v8::Signature::New(isolate, recv))\n\t);\n}\nvoid SetPrototypeSymbolMethod(\n\tv8::Isolate* isolate,\n\tv8::Local<v8::External> data,\n\tv8::Local<v8::FunctionTemplate> recv,\n\tv8::Local<v8::Symbol> symbol,\n\tv8::FunctionCallback func\n) {\n\tv8::HandleScope scope(isolate);\n\trecv->PrototypeTemplate()->Set(\n\t\tsymbol,\n\t\tv8::FunctionTemplate::New(isolate, func, data, v8::Signature::New(isolate, recv))\n\t);\n}\nvoid SetPrototypeGetter(\n\tv8::Isolate* isolate,\n\tv8::Local<v8::External> data,\n\tv8::Local<v8::FunctionTemplate> recv,\n\tconst char* name,\n\tv8::AccessorGetterCallback func\n) {\n\tv8::HandleScope scope(isolate);\n\trecv->InstanceTemplate()->SetAccessor(\n\t\tInternalizedFromLatin1(isolate, name),\n\t\tfunc,\n\t\t0,\n\t\tdata,\n\t\tv8::AccessControl::DEFAULT,\n\t\tv8::PropertyAttribute::None,\n\t\tv8::AccessorSignature::New(isolate, recv)\n\t);\n}\n"