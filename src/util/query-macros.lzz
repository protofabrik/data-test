"#define STATEMENT_BIND(handle)                                                 \\\n\tBinder binder(handle);                                                     \\\n\tif (!binder.Bind(info, info.Length(), stmt)) {                             \\\n\t\tsqlite3_clear_bindings(handle);                                        \\\n\t\treturn;                                                                \\\n\t} ((void)0)\n\n#define STATEMENT_THROW_LOGIC()                                                \\\n\tdb->ThrowDatabaseError();                                                  \\\n\tif (!bound) { sqlite3_clear_bindings(handle); }                            \\\n\treturn\n\n#define STATEMENT_RETURN_LOGIC(return_value)                                   \\\n\tinfo.GetReturnValue().Set(return_value);                                   \\\n\tif (!bound) { sqlite3_clear_bindings(handle); }                            \\\n\treturn\n\n#define STATEMENT_START_LOGIC(RETURNS_DATA_CHECK, MUTATE_CHECK)                \\\n\tStatement* stmt = Unwrap<Statement>(info.This());                          \\\n\tRETURNS_DATA_CHECK();                                                      \\\n\tsqlite3_stmt* handle = stmt->handle;                                       \\\n\tDatabase* db = stmt->db;                                                   \\\n\tREQUIRE_DATABASE_OPEN(db->GetState());                                     \\\n\tREQUIRE_DATABASE_NOT_BUSY(db->GetState());                                 \\\n\tMUTATE_CHECK();                                                            \\\n\tconst bool bound = stmt->bound;                                            \\\n\tif (!bound) {                                                              \\\n\t\tSTATEMENT_BIND(handle);                                                \\\n\t} else if (info.Length() > 0) {                                            \\\n\t\treturn ThrowTypeError(\"This statement already has bound parameters\");  \\\n\t} ((void)0)\n\n\n#define STATEMENT_THROW() db->GetState()->busy = false; STATEMENT_THROW_LOGIC()\n#define STATEMENT_RETURN(x) db->GetState()->busy = false; STATEMENT_RETURN_LOGIC(x)\n#define STATEMENT_START(x, y)                                                  \\\n\tSTATEMENT_START_LOGIC(x, y);                                               \\\n\tdb->GetState()->busy = true;                                               \\\n\tUseIsolate;                                                                \\\n\tif (db->Log(isolate, handle)) {                                            \\\n\t\tSTATEMENT_THROW();                                                     \\\n\t} ((void)0)\n\n\n#define DOES_NOT_MUTATE() REQUIRE_STATEMENT_NOT_LOCKED(stmt)\n#define DOES_MUTATE()                                                          \\\n\tassert(!stmt->locked);                                                     \\\n\tREQUIRE_DATABASE_NO_ITERATORS_UNLESS_UNSAFE(db->GetState())\n#define DOES_ADD_ITERATOR()                                                    \\\n\tDOES_NOT_MUTATE();                                                         \\\n\tif (db->GetState()->iterators == USHRT_MAX)                                \\\n\t\treturn ThrowRangeError(\"Too many active database iterators\")\n#define REQUIRE_STATEMENT_RETURNS_DATA()                                       \\\n\tif (!stmt->returns_data)                                                   \\\n\t\treturn ThrowTypeError(\"This statement does not return data. Use run() instead\")\n#define REQUIRE_STATEMENT_DOESNT_RETURN_DATA()                                 \\\n\tif (stmt->returns_data)                                                    \\\n\t\treturn ThrowTypeError(\"This statement returns data. Use get(), all(), or iterate() instead\")\n\n\n#define _FUNCTION_START(type)                                                  \\\n\ttype* self = static_cast<type*>(sqlite3_user_data(invocation));            \\\n\tv8::Isolate* isolate = self->isolate;                                      \\\n\tv8::HandleScope scope(isolate)\n\n#define FUNCTION_START()                                                       \\\n\t_FUNCTION_START(CustomFunction)\n\n#define AGGREGATE_START()                                                      \\\n\t_FUNCTION_START(CustomAggregate);                                          \\\n\tAccumulator* acc = self->GetAccumulator(invocation);                       \\\n\tif (acc->value.IsEmpty()) return\n"