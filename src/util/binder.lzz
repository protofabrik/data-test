"class Binder {\npublic:\n\n\texplicit Binder(sqlite3_stmt* _handle) {\n\t\thandle = _handle;\n\t\tparam_count = sqlite3_bind_parameter_count(_handle);\n\t\tanon_index = 0;\n\t\tsuccess = true;\n\t}\n\n\tbool Bind(NODE_ARGUMENTS info, int argc, Statement* stmt) {\n\t\tassert(anon_index == 0);\n\t\tResult result = BindArgs(info, argc, stmt);\n\t\tif (success && result.count != param_count) {\n\t\t\tif (result.count < param_count) {\n\t\t\t\tif (!result.bound_object && stmt->GetBindMap(OnlyIsolate)->GetSize()) {\n\t\t\t\t\tFail(ThrowTypeError, \"Missing named parameters\");\n\t\t\t\t} else {\n\t\t\t\t\tFail(ThrowRangeError, \"Too few parameter values were provided\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFail(ThrowRangeError, \"Too many parameter values were provided\");\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t}\n\nprivate:\n\tstruct Result {\n\t\tint count;\n\t\tbool bound_object;\n\t};\n\n\tstatic bool IsPlainObject(v8::Isolate* isolate, v8::Local<v8::Object> obj) {\n\t\tv8::Local<v8::Value> proto = obj->GetPrototype();\n\t\tv8::Local<v8::Context> ctx = obj->CreationContext();\n\t\tctx->Enter();\n\t\tv8::Local<v8::Value> baseProto = v8::Object::New(isolate)->GetPrototype();\n\t\tctx->Exit();\n\t\treturn proto->StrictEquals(baseProto) || proto->StrictEquals(v8::Null(isolate));\n\t}\n\n\tvoid Fail(void (*Throw)(const char* _), const char* message) {\n\t\tassert(success == true);\n\t\tassert((Throw == NULL) == (message == NULL));\n\t\tassert(Throw == ThrowError || Throw == ThrowTypeError || Throw == ThrowRangeError || Throw == NULL);\n\t\tif (Throw) Throw(message);\n\t\tsuccess = false;\n\t}\n\n\tint NextAnonIndex() {\n\t\twhile (sqlite3_bind_parameter_name(handle, ++anon_index) != NULL) {}\n\t\treturn anon_index;\n\t}\n\n\t// Binds the value at the given index or throws an appropriate error.\n\tvoid BindValue(v8::Isolate* isolate, v8::Local<v8::Value> value, int index) {\n\t\tint status = Data::BindValueFromJS(isolate, handle, index, value);\n\t\tif (status != SQLITE_OK) {\n\t\t\tswitch (status) {\n\t\t\t\tcase -1:\n\t\t\t\t\treturn Fail(ThrowTypeError, \"SQLite3 can only bind numbers, strings, bigints, buffers, and null\");\n\t\t\t\tcase SQLITE_TOOBIG:\n\t\t\t\t\treturn Fail(ThrowRangeError, \"The bound string, buffer, or bigint is too big\");\n\t\t\t\tcase SQLITE_RANGE:\n\t\t\t\t\treturn Fail(ThrowRangeError, \"Too many parameter values were provided\");\n\t\t\t\tcase SQLITE_NOMEM:\n\t\t\t\t\treturn Fail(ThrowError, \"Out of memory\");\n\t\t\t\tdefault:\n\t\t\t\t\treturn Fail(ThrowError, \"An unexpected error occured while trying to bind parameters\");\n\t\t\t}\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\t// Binds each value in the array or throws an appropriate error.\n\t// The number of successfully bound parameters is returned.\n\tint BindArray(v8::Isolate* isolate, v8::Local<v8::Array> arr) {\n\t\tUseContext;\n\t\tuint32_t length = arr->Length();\n\t\tif (length > INT_MAX) {\n\t\t\tFail(ThrowRangeError, \"Too many parameter values were provided\");\n\t\t\treturn 0;\n\t\t}\n\t\tint len = static_cast<int>(length);\n\t\tfor (int i=0; i<len; ++i) {\n\t\t\tv8::MaybeLocal<v8::Value> maybeValue = arr->Get(ctx, i);\n\t\t\tif (maybeValue.IsEmpty()) {\n\t\t\t\tFail(NULL, NULL);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tBindValue(isolate, maybeValue.ToLocalChecked(), NextAnonIndex());\n\t\t\tif (!success) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\t// Binds all named parameters using the values found in the given object.\n\t// The number of successfully bound parameters is returned.\n\t// If a named parameter is missing from the object, an error is thrown.\n\t// This should only be invoked once per instance.\n\tint BindObject(v8::Isolate* isolate, v8::Local<v8::Object> obj, Statement* stmt) {\n\t\tUseContext;\n\t\tBindMap* bind_map = stmt->GetBindMap(isolate);\n\t\tBindMap::Pair* pairs = bind_map->GetPairs();\n\t\tint len = bind_map->GetSize();\n\n\t\tfor (int i=0; i<len; ++i) {\n\t\t\tv8::Local<v8::String> key = pairs[i].GetName(isolate);\n\n\t\t\t// Check if the named parameter was provided.\n\t\t\tv8::Maybe<bool> has_property = obj->HasOwnProperty(ctx, key);\n\t\t\tif (has_property.IsNothing()) {\n\t\t\t\tFail(NULL, NULL);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (!has_property.FromJust()) {\n\t\t\t\tv8::String::Utf8Value param_name(isolate, key);\n\t\t\t\tFail(ThrowRangeError, CONCAT(\"Missing named parameter \\\"\", *param_name, \"\\\"\").c_str());\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\t// Get the current property value.\n\t\t\tv8::MaybeLocal<v8::Value> maybeValue = obj->Get(ctx, key);\n\t\t\tif (maybeValue.IsEmpty()) {\n\t\t\t\tFail(NULL, NULL);\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tBindValue(isolate, maybeValue.ToLocalChecked(), pairs[i].GetIndex());\n\t\t\tif (!success) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn len;\n\t}\n\n\t// Binds all parameters using the values found in the arguments object.\n\t// Anonymous parameter values can be directly in the arguments object or in an Array.\n\t// Named parameter values can be provided in a plain Object argument.\n\t// Only one plain Object argument may be provided.\n\t// If an error occurs, an appropriate error is thrown.\n\t// The return value is a struct indicating how many parameters were successfully bound\n\t// and whether or not it tried to bind an object.\n\tResult BindArgs(NODE_ARGUMENTS info, int argc, Statement* stmt) {\n\t\tUseIsolate;\n\t\tint count = 0;\n\t\tbool bound_object = false;\n\n\t\tfor (int i=0; i<argc; ++i) {\n\t\t\tv8::Local<v8::Value> arg = info[i];\n\n\t\t\tif (arg->IsArray()) {\n\t\t\t\tcount += BindArray(isolate, v8::Local<v8::Array>::Cast(arg));\n\t\t\t\tif (!success) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (arg->IsObject() && !node::Buffer::HasInstance(arg)) {\n\t\t\t\tv8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(arg);\n\t\t\t\tif (IsPlainObject(isolate, obj)) {\n\t\t\t\t\tif (bound_object) {\n\t\t\t\t\t\tFail(ThrowTypeError, \"You cannot specify named parameters in two different objects\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbound_object = true;\n\n\t\t\t\t\tcount += BindObject(isolate, obj, stmt);\n\t\t\t\t\tif (!success) break;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBindValue(isolate, arg, NextAnonIndex());\n\t\t\tif (!success) break;\n\t\t\tcount += 1;\n\t\t}\n\n\t\treturn { count, bound_object };\n\t}\n\n\tsqlite3_stmt* handle;\n\tint param_count;\n\tint anon_index; // This value should only be used by NextAnonIndex()\n\tbool success; // This value should only be set by Fail()\n};\n"