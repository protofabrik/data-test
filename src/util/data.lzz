"#define JS_VALUE_TO_SQLITE(to, value, isolate, ...)                            \\\n\tif (value->IsNumber()) {                                                   \\\n\t\treturn sqlite3_##to##_double(                                          \\\n\t\t\t__VA_ARGS__,                                                       \\\n\t\t\tv8::Local<v8::Number>::Cast(value)->Value()                        \\\n\t\t);                                                                     \\\n\t} else if (value->IsBigInt()) {                                            \\\n\t\tbool lossless;                                                         \\\n\t\tint64_t v = v8::Local<v8::BigInt>::Cast(value)->Int64Value(&lossless); \\\n\t\tif (lossless) {                                                        \\\n\t\t\treturn sqlite3_##to##_int64(__VA_ARGS__, v);                       \\\n\t\t}                                                                      \\\n\t} else if (value->IsString()) {                                            \\\n\t\tv8::String::Utf8Value utf8(                                            \\\n\t\t\tisolate,                                                           \\\n\t\t\tv8::Local<v8::String>::Cast(value)                                 \\\n\t\t);                                                                     \\\n\t\treturn sqlite3_##to##_text(                                            \\\n\t\t\t__VA_ARGS__,                                                       \\\n\t\t\t*utf8,                                                             \\\n\t\t\tutf8.length(),                                                     \\\n\t\t\tSQLITE_TRANSIENT                                                   \\\n\t\t);                                                                     \\\n\t} else if (node::Buffer::HasInstance(value)) {                             \\\n\t\treturn sqlite3_##to##_blob(                                            \\\n\t\t\t__VA_ARGS__,                                                       \\\n\t\t\tnode::Buffer::Data(value),                                         \\\n\t\t\tnode::Buffer::Length(value),                                       \\\n\t\t\tSQLITE_TRANSIENT                                                   \\\n\t\t);                                                                     \\\n\t} else if (value->IsNull() || value->IsUndefined()) {                      \\\n\t\treturn sqlite3_##to##_null(__VA_ARGS__);                               \\\n\t}\n\n#define SQLITE_VALUE_TO_JS(from, isolate, safe_ints, ...)                      \\\n\tswitch (sqlite3_##from##_type(__VA_ARGS__)) {                              \\\n\tcase SQLITE_INTEGER:                                                       \\\n\t\tif (safe_ints) {                                                       \\\n\t\t\treturn v8::BigInt::New(                                            \\\n\t\t\t\tisolate,                                                       \\\n\t\t\t\tsqlite3_##from##_int64(__VA_ARGS__)                            \\\n\t\t\t);                                                                 \\\n\t\t}                                                                      \\\n\tcase SQLITE_FLOAT:                                                         \\\n\t\treturn v8::Number::New(                                                \\\n\t\t\tisolate,                                                           \\\n\t\t\tsqlite3_##from##_double(__VA_ARGS__)                               \\\n\t\t);                                                                     \\\n\tcase SQLITE_TEXT:                                                          \\\n\t\treturn StringFromUtf8(                                                 \\\n\t\t\tisolate,                                                           \\\n\t\t\treinterpret_cast<const char*>(sqlite3_##from##_text(__VA_ARGS__)), \\\n\t\t\tsqlite3_##from##_bytes(__VA_ARGS__)                                \\\n\t\t);                                                                     \\\n\tcase SQLITE_BLOB:                                                          \\\n\t\treturn node::Buffer::Copy(                                             \\\n\t\t\tisolate,                                                           \\\n\t\t\tstatic_cast<const char*>(sqlite3_##from##_blob(__VA_ARGS__)),      \\\n\t\t\tsqlite3_##from##_bytes(__VA_ARGS__)                                \\\n\t\t).ToLocalChecked();                                                    \\\n\tdefault:                                                                   \\\n\t\tassert(sqlite3_##from##_type(__VA_ARGS__) == SQLITE_NULL);             \\\n\t\treturn v8::Null(isolate);                                              \\\n\t}                                                                          \\\n\tassert(false);\n\nnamespace Data {\n\n\tstatic const char FLAT = 0;\n\tstatic const char PLUCK = 1;\n\tstatic const char EXPAND = 2;\n\tstatic const char RAW = 3;\n\n\tv8::Local<v8::Value> GetValueJS(v8::Isolate* isolate, sqlite3_stmt* handle, int column, bool safe_ints) {\n\t\tSQLITE_VALUE_TO_JS(column, isolate, safe_ints, handle, column);\n\t}\n\n\tv8::Local<v8::Value> GetValueJS(v8::Isolate* isolate, sqlite3_value* value, bool safe_ints) {\n\t\tSQLITE_VALUE_TO_JS(value, isolate, safe_ints, value);\n\t}\n\n\tv8::Local<v8::Value> GetFlatRowJS(v8::Isolate* isolate, v8::Local<v8::Context> ctx, sqlite3_stmt* handle, bool safe_ints) {\n\t\tv8::Local<v8::Object> row = v8::Object::New(isolate);\n\t\tint column_count = sqlite3_column_count(handle);\n\t\tfor (int i=0; i<column_count; ++i) {\n\t\t\trow->Set(ctx,\n\t\t\t\tInternalizedFromUtf8(isolate, sqlite3_column_name(handle, i), -1),\n\t\t\t\tData::GetValueJS(isolate, handle, i, safe_ints)).FromJust();\n\t\t}\n\t\treturn row;\n\t}\n\n\tv8::Local<v8::Value> GetExpandedRowJS(v8::Isolate* isolate, v8::Local<v8::Context> ctx, sqlite3_stmt* handle, bool safe_ints) {\n\t\tv8::Local<v8::Object> row = v8::Object::New(isolate);\n\t\tint column_count = sqlite3_column_count(handle);\n\t\tfor (int i=0; i<column_count; ++i) {\n\t\t\tconst char* table_raw = sqlite3_column_table_name(handle, i);\n\t\t\tv8::Local<v8::String> table = InternalizedFromUtf8(isolate, table_raw == NULL ? \"$\" : table_raw, -1);\n\t\t\tv8::Local<v8::String> column = InternalizedFromUtf8(isolate, sqlite3_column_name(handle, i), -1);\n\t\t\tv8::Local<v8::Value> value = Data::GetValueJS(isolate, handle, i, safe_ints);\n\t\t\tif (row->HasOwnProperty(ctx, table).FromJust()) {\n\t\t\t\tv8::Local<v8::Object>::Cast(row->Get(ctx, table).ToLocalChecked())->Set(ctx, column, value).FromJust();\n\t\t\t} else {\n\t\t\t\tv8::Local<v8::Object> nested = v8::Object::New(isolate);\n\t\t\t\trow->Set(ctx, table, nested).FromJust();\n\t\t\t\tnested->Set(ctx, column, value).FromJust();\n\t\t\t}\n\t\t}\n\t\treturn row;\n\t}\n\n\tv8::Local<v8::Value> GetRawRowJS(v8::Isolate* isolate, v8::Local<v8::Context> ctx, sqlite3_stmt* handle, bool safe_ints) {\n\t\tv8::Local<v8::Array> row = v8::Array::New(isolate);\n\t\tint column_count = sqlite3_column_count(handle);\n\t\tfor (int i=0; i<column_count; ++i) {\n\t\t\trow->Set(ctx, i, Data::GetValueJS(isolate, handle, i, safe_ints)).FromJust();\n\t\t}\n\t\treturn row;\n\t}\n\n\tv8::Local<v8::Value> GetRowJS(v8::Isolate* isolate, v8::Local<v8::Context> ctx, sqlite3_stmt* handle, bool safe_ints, char mode) {\n\t\tif (mode == FLAT) return GetFlatRowJS(isolate, ctx, handle, safe_ints);\n\t\tif (mode == PLUCK) return GetValueJS(isolate, handle, 0, safe_ints);\n\t\tif (mode == EXPAND) return GetExpandedRowJS(isolate, ctx, handle, safe_ints);\n\t\tif (mode == RAW) return GetRawRowJS(isolate, ctx, handle, safe_ints);\n\t\tassert(false);\n\t\treturn v8::Local<v8::Value>();\n\t}\n\n\tvoid GetArgumentsJS(v8::Isolate* isolate, v8::Local<v8::Value>* out, sqlite3_value** values, int argument_count, bool safe_ints) {\n\t\tassert(argument_count > 0);\n\t\tfor (int i=0; i<argument_count; ++i) {\n\t\t\tout[i] = Data::GetValueJS(isolate, values[i], safe_ints);\n\t\t}\n\t}\n\n\tint BindValueFromJS(v8::Isolate* isolate, sqlite3_stmt* handle, int index, v8::Local<v8::Value> value) {\n\t\tJS_VALUE_TO_SQLITE(bind, value, isolate, handle, index);\n\t\treturn value->IsBigInt() ? SQLITE_TOOBIG : -1;\n\t}\n\n\tvoid ResultValueFromJS(v8::Isolate* isolate, sqlite3_context* invocation, v8::Local<v8::Value> value, CustomFunction* function) {\n\t\tJS_VALUE_TO_SQLITE(result, value, isolate, invocation);\n\t\tfunction->ThrowResultValueError(invocation, value->IsBigInt());\n\t}\n\n}\n"