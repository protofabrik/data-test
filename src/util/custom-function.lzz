"class CustomFunction {\npublic:\n\n\texplicit CustomFunction(v8::Isolate* _isolate, Database* _db, v8::Local<v8::Function> _fn, const char* _name, bool _safe_ints)\n\t\t: name(COPY(_name)), db(_db), isolate(_isolate), fn(_isolate, _fn), safe_ints(_safe_ints) {}\n\tvirtual ~CustomFunction() { delete[] name; }\n\n\tstatic void xDestroy(void* self) {\n\t\tdelete static_cast<CustomFunction*>(self);\n\t}\n\n\tstatic void xFunc(sqlite3_context* invocation, int argc, sqlite3_value** argv) {\n\t\tFUNCTION_START();\n\n\t\tv8::Local<v8::Value> args_fast[4];\n\t\tv8::Local<v8::Value>* args = NULL;\n\t\tif (argc != 0) {\n\t\t\targs = argc <= 4 ? args_fast : ALLOC_ARRAY<v8::Local<v8::Value>>(argc);\n\t\t\tData::GetArgumentsJS(isolate, args, argv, argc, self->safe_ints);\n\t\t}\n\n\t\tv8::MaybeLocal<v8::Value> maybe_return_value = v8::Local<v8::Function>::New(isolate, self->fn)->Call(OnlyContext, v8::Undefined(isolate), argc, args);\n\t\tif (args != args_fast) delete[] args;\n\n\t\tif (maybe_return_value.IsEmpty()) self->PropagateJSError(invocation);\n\t\telse Data::ResultValueFromJS(isolate, invocation, maybe_return_value.ToLocalChecked(), self);\n\t}\n\n\tvoid ThrowResultValueError(sqlite3_context* invocation, bool isBigInt) {\n\t\tif (isBigInt) {\n\t\t\tThrowRangeError(CONCAT(\"User-defined function \", name, \"() returned a bigint that was too big\").c_str());\n\t\t} else {\n\t\t\tThrowTypeError(CONCAT(\"User-defined function \", name, \"() returned an invalid value\").c_str());\n\t\t}\n\t\tPropagateJSError(invocation);\n\t}\n\nprotected:\n\tvirtual void PropagateJSError(sqlite3_context* invocation) {\n\t\tassert(db->GetState()->was_js_error == false);\n\t\tdb->GetState()->was_js_error = true;\n\t\tsqlite3_result_error(invocation, \"\", 0);\n\t}\n\nprivate:\n\tconst char* const name;\n\tDatabase* const db;\nprotected:\n\tv8::Isolate* const isolate;\n\tconst CopyablePersistent<v8::Function> fn;\n\tconst bool safe_ints;\n};\n"