"#hdr\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <sqlite3.h>\n#include <node.h>\n#include <node_object_wrap.h>\n#include <node_buffer.h>\n#end\n\n#insert \"util/macros.lzz\"\n#insert \"util/query-macros.lzz\"\n#insert \"util/constants.lzz\"\n#insert \"util/bind-map.lzz\"\nstruct Addon;\nclass Statement;\nclass Backup;\n#insert \"objects/database.lzz\"\n#insert \"objects/statement.lzz\"\n#insert \"objects/statement-iterator.lzz\"\n#insert \"objects/backup.lzz\"\n#insert \"util/custom-function.lzz\"\n#insert \"util/custom-aggregate.lzz\"\n#insert \"util/data.lzz\"\n#insert \"util/binder.lzz\"\n\nstruct Addon {\n\tAddon(v8::Isolate* isolate) : privileged_info(NULL), bit_field(0), cs(isolate) {}\n\n\tCopyablePersistent<v8::Function> Statement;\n\tCopyablePersistent<v8::Function> StatementIterator;\n\tCopyablePersistent<v8::Function> Backup;\n\tCopyablePersistent<v8::Function> SqliteError;\n\tNODE_ARGUMENTS_POINTER privileged_info;\n\tsqlite3_uint64 bit_field;\n\tCS cs;\n\tstd::set<Database*, Database::CompareDatabase> dbs;\n\n\tNODE_METHOD(JS_setErrorConstructor) {\n\t\tREQUIRE_ARGUMENT_FUNCTION(first, v8::Local<v8::Function> SqliteError);\n\t\tOnlyAddon->SqliteError.Reset(OnlyIsolate, SqliteError);\n\t}\n\n\tstatic void Cleanup(void* ptr) {\n\t\tAddon* addon = static_cast<Addon*>(ptr);\n\t\tfor (Database* db : addon->dbs) db->CloseHandles();\n\t\taddon->dbs.clear();\n\t\tdelete addon;\n\t}\n\n\tinline sqlite3_uint64 NextId() {\n\t\treturn (bit_field++ << 1) >> 1;\n\t}\n\tinline bool PragmaMode() {\n\t\treturn bit_field >> 63 != 0;\n\t}\n\tinline void SetPragmaMode(bool active) {\n\t\tbit_field = (bit_field << 1) >> 1 | static_cast<sqlite3_uint64>(active) << 63;\n\t}\n};\n\n#src\nNODE_MODULE_INIT(/* exports, context */) {\n\tv8::Isolate* isolate = context->GetIsolate();\n\tv8::HandleScope scope(isolate);\n\n\t// Initialize addon instance.\n\tAddon* addon = new Addon(isolate);\n\tv8::Local<v8::External> data = v8::External::New(isolate, addon);\n\tnode::AddEnvironmentCleanupHook(isolate, Addon::Cleanup, addon);\n\n\t// Create and export native-backed classes and functions.\n\texports->Set(context, InternalizedFromLatin1(isolate, \"Database\"), Database::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"Statement\"), Statement::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"StatementIterator\"), StatementIterator::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"Backup\"), Backup::Init(isolate, data)).FromJust();\n\texports->Set(context, InternalizedFromLatin1(isolate, \"setErrorConstructor\"), v8::FunctionTemplate::New(isolate, Addon::JS_setErrorConstructor, data)->GetFunction(context).ToLocalChecked()).FromJust();\n\n\t// Store addon instance data.\n\taddon->Statement.Reset(isolate, v8::Local<v8::Function>::Cast(exports->Get(context, InternalizedFromLatin1(isolate, \"Statement\")).ToLocalChecked()));\n\taddon->StatementIterator.Reset(isolate, v8::Local<v8::Function>::Cast(exports->Get(context, InternalizedFromLatin1(isolate, \"StatementIterator\")).ToLocalChecked()));\n\taddon->Backup.Reset(isolate, v8::Local<v8::Function>::Cast(exports->Get(context, InternalizedFromLatin1(isolate, \"Backup\")).ToLocalChecked()));\n}\n#end\n"