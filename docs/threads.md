"# Worker threads\n\nFor most applications, `better-sqlite3` is fast enough to use in the main thread without blocking for a noticeable amount of time. However, if you need to perform very slow queries, you have the option of using [worker threads](https://nodejs.org/api/worker_threads.html) to keep things running smoothly. Below is an example of using a thread pool to perform queries in the background.\n\n### worker.js\n\nThe worker logic is very simple in our case. It accepts messages from the master thread, executes each message's SQL (with any given parameters), and sends back the query results.\n\n```js\nconst { parentPort } = require('worker_threads');\nconst db = require('better-sqlite3')('foobar.db');\n\nparentPort.on('message', ({ sql, parameters }) => {\n  const result = db.prepare(sql).all(...parameters);\n  parentPort.postMessage(result);\n});\n```\n\n### master.js\n\nThe master thread is responsible for spawning workers, respawning threads that crash, and accepting query jobs.\n\n```js\nconst { Worker } = require('worker_threads');\nconst os = require('os');\n\n/*\n  Export a function that queues pending work.\n */\n\nconst queue = [];\nexports.asyncQuery = (sql, ...parameters) => {\n  return new Promise((resolve, reject) => {\n    queue.push({\n      resolve,\n      reject,\n      message: { sql, parameters },\n    });\n  });\n};\n\n/*\n  Spawn workers that try to drain the queue.\n */\n\nos.cpus().forEach(function spawn() {\n  const worker = new Worker('./worker.js');\n\n  let job = null; // Current item from the queue\n  let error = null; // Error that caused the worker to crash\n  let timer = null; // Timer used for polling\n\n  function poll() {\n    if (queue.length) {\n      // If there's a job in the queue, send it to the worker\n      job = queue.shift();\n      worker.postMessage(job.message);\n    } else {\n      // Otherwise, check again later\n      timer = setImmediate(poll);\n    }\n  }\n\n  worker\n    .on('online', poll)\n    .on('message', (result) => {\n      job.resolve(result);\n      job = null;\n      poll(); // Check if there's more work to do\n    })\n    .on('error', (err) => {\n      console.error(err);\n      error = err;\n    })\n    .on('exit', (code) => {\n      clearImmediate(timer);\n      if (job) {\n        job.reject(error || new Error('worker died'));\n      }\n      if (code !== 0) {\n        console.error(`worker exited with code ${code}`);\n        spawn(); // Worker died, so spawn a new one\n      }\n    });\n});\n```\n"