"'use strict';\nexports.readonly = false; // Inserting 100 rows in a single transaction\n\nexports['better-sqlite3'] = (db, { table, columns }) => {\n\tconst stmt = db.prepare(`INSERT INTO ${table} (${columns.join(', ')}) VALUES (${columns.map(x => '@' + x).join(', ')})`);\n\tconst row = db.prepare(`SELECT * FROM ${table} LIMIT 1`).get();\n\tconst trx = db.transaction((row) => {\n\t\tfor (let i = 0; i < 100; ++i) stmt.run(row);\n\t});\n\treturn () => trx(row);\n};\n\nexports['node-sqlite3'] = async (db, { table, columns, driver, pragma }) => {\n\tconst sql = `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${columns.map(x => '@' + x).join(', ')})`;\n\tconst row = Object.assign({}, ...Object.entries(await db.get(`SELECT * FROM ${table} LIMIT 1`))\n\t\t.filter(([k]) => columns.includes(k))\n\t\t.map(([k, v]) => ({ ['@' + k]: v })));\n\tconst open = require('../drivers').get(driver);\n\t/*\n\t\tThe only way to create an isolated transaction with node-sqlite3 in a\n\t\trandom-access environment (i.e., a web server) is to open a new database\n\t\tconnection for each transaction.\n\t\t(http://github.com/mapbox/node-sqlite3/issues/304#issuecomment-45242331)\n\t */\n\treturn () => open('../temp/benchmark.db', pragma).then(async (db) => {\n\t\ttry {\n\t\t\tawait db.run('BEGIN');\n\t\t\ttry {\n\t\t\t\tfor (let i = 0; i < 100; ++i) await db.run(sql, row);\n\t\t\t\tawait db.run('COMMIT');\n\t\t\t} catch (err) {\n\t\t\t\ttry { await db.run('ROLLBACK'); }\n\t\t\t\tcatch (_) { /* this is necessary because there's no db.inTransaction property */ }\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t} finally {\n\t\t\tawait db.close();\n\t\t}\n\t});\n};\n"